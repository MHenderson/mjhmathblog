[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mjhmathblog",
    "section": "",
    "text": "Generating Examples of Maximal Room Squares in R\n\n\n\n\n\n\ncombinatorics\n\nroom-squares\n\n\n\n\n\n\n\n\n\nMay 4, 2023\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nEuler Paths\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nOct 17, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nGreedy Edge Colouring of Small Graphs\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nSep 26, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nMore on Moore Graphs\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nSep 12, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nChromatic Indices of Small Graphs\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nAug 29, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nSmall Moore Graphs\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nAug 22, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nColouring Small Regular Graphs\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nAug 15, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nColouring Small Graphs: Update\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nAug 8, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nColouring Small Graphs\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nJul 25, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nA Chromatic Number Program\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nJul 18, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nChromatic Polynomials\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nJul 11, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nVertex Colouring by Recursive Removal of Independent Sets of Vertices\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nJul 4, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nImproved Greedy Colouring of Small Graphs\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nJun 27, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nStrategies for Greedy Vertex Colouring\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nJun 20, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nGreedy Vertex Colouring\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nJun 13, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nProcessing Graph Streams\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nJun 6, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nDrawing Coloured Queen Graphs\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nMay 30, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Greedy Colouring\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nMay 23, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nLombardi Drawings\n\n\n\n\n\n\ngraph-theory\n\n\n\n\n\n\n\n\n\nMay 9, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nBasic Graph Drawing\n\n\n\n\n\n\ngraph-theory\n\ngraph-drawing\n\npython\n\nnetworkx\n\n\n\n\n\n\n\n\n\nMay 2, 2014\n\n\nMatthew Henderson\n\n\n\n\n\n\n\n\n\n\n\n\nPlane Drawings of Lobsters\n\n\n\n\n\n\ngraph-theory\n\ngraph-drawing\n\npython\n\nnetworkx\n\ngephi\n\n\n\n\n\n\n\n\n\nApr 25, 2014\n\n\nMatthew Henderson\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2014-05-23-introduction-to-greedy-colouring/index.html",
    "href": "posts/2014-05-23-introduction-to-greedy-colouring/index.html",
    "title": "Introduction to Greedy Colouring",
    "section": "",
    "text": "In the post we discuss Joseph Culberson’s Graph Colouring Programs, a collection of C programs which can be downloaded from Culberson’s Graph Colouring Page.\nThis post has four sections. In the first, we show to use greedy in the manner it was designed to be used, interactively. In the second section we introduce a new wrapper interface, ccli, which can be used to drive greedy and the other of Culberson’s Colouring Programs in a non-interactive way which is suitable for automated experimentation and has benefits for reproducibility. In the third section we describe a general scheme for using greedy to approximate the chromatic number of graphs. In the final section we demonstrate this approach through a toy experiment into the chromatic number of queen graphs."
  },
  {
    "objectID": "posts/2014-05-23-introduction-to-greedy-colouring/index.html#interactive-usage",
    "href": "posts/2014-05-23-introduction-to-greedy-colouring/index.html#interactive-usage",
    "title": "Introduction to Greedy Colouring",
    "section": "Interactive usage",
    "text": "Interactive usage\nAll of Culberson’s Colouring Programs, including greedy, require input graph data to be given in DIMACS format. In this section we will demonstrate how to use greedy to find a colouring of the Chvatal Graph which can be found in DIMACS format in the graphs-collection collection of graphs.\nTo use greedy to colour a graph, call the program from the command-line and pass the path to the graph data in DIMACS format as an argument.\n$ greedy chvatal.dimacs\nAfter an interactive session, detailed below, the resulting colouring will be appended to a.res (where a is the original filename, including extension). This file will be created if it doesn’t already exist.\nBefore the colouring is produced, however, we have to participate in an interactive session with greedy to determine some options used by the program in producing the colouring. The first of these options is about whether we wish to a use a cheat colouring inside the input file as a target colouring. The purpose of this cheat is explained further in the greedy documentation. We won’t be using it here, so we respond negatively.\nJ. Culberson's Implementation of\n        GREEDY\nA program for coloring graphs.\nFor more information visit the webpages at:\n\n    http://www.cs.ualberta.ca/~joe/Coloring/index.html\n\nThis program is available for research and educational purposes only.\nThere is no warranty of any kind.\n\n    Enjoy!\n\nDo you wish to use the cheat if present? (0-no, 1-yes)\n0\nThe next option we are prompted for is a seed to be used for randomisation. This provides us with the ability to generate different random colourings and also to reproduce previously randomised colourings.\nASCII format\nnumber of vertices = 12\np edge 12 24\nNumber of edges = 24 edges read = 24\nGRAPH SETUP cpu =  0.00\nEnter seed for search randomization:\n1\nResponding with 1 leads us to a choice about the type of greedy algorithm we want to use. There are six types. Again, for more information see the greedy documentation. For now we will use the simple greedy algorithm.\nProcess pid = 5315\nGREEDY TYPE SELECTION\n    1   Simple Greedy\n    2   Largest First Greedy\n    3   Smallest First Greedy\n    4   Random Sequence Greedy\n    5   Reverse Order Greedy\n    6   Stir Color Greedy\nWhich for this program\n1\nThe next option concerns the way in which vertices are ordered before the algorithm starts running. The default is inorder, the order vertices are given in the input graph file.\nInitial Vertex Ordering:\n    1 -- inorder\n    2 -- random\n    3 -- decreasing degree\n    4 -- increasing degree\n    5 -- LBFS random\n    6 -- LBFS decreasing degree\n    7 -- LBFS increasing degree\nUsing:\n1\nChoosing inorder for our initial vertex ordering leads us to the final option, whether or not we wish the algorithm to use the method of Kempe reductions.\nUse kempe reductions y/n\nn\nThe output is in a file called chvatal.dimacs.res and, after only one call, looks like this:\nCLRS 4 FROM GREEDY cpu =  0.00 pid = 5315\n  1   2   1   2   3   1   2   1   2   3   4   4\nThis is to be interpreted as a colouring of vertices. The first vertex gets colour 1, the second colour 2, the third colour 1 and so on. With multiple calls this file is augmented with additional lines of data in this format. This gives us a simple way of collecting information about many different runs of the same program, possibly with different options, on the same data."
  },
  {
    "objectID": "posts/2014-05-23-introduction-to-greedy-colouring/index.html#non-interactive-use",
    "href": "posts/2014-05-23-introduction-to-greedy-colouring/index.html#non-interactive-use",
    "title": "Introduction to Greedy Colouring",
    "section": "Non-Interactive Use",
    "text": "Non-Interactive Use\nIn some situations, especially when running multiple simulations with different parameters, it can be useful to use programs non-interactively. Other benefits to this approach are that it makes it easier to chain commands together in a shell environment, for example to take the output of a colouring program and use it as part of the input to another program that draws a graph and colours nodes according to the resulting colouring. Another benefit is that it makes easier the task of documenting and communicating experimental conditions. This, in turn, can have benefits for reproducibility of results.\nFor this reason we have developed ccli Culberson’s (Colouring Programs) Command-Line Interface, a wrapper script around Culberson’s programs that gives them a non-interactive interface. Although still under development, ccli currently can provide a complete interface to several of the programs, including greedy.\nccli is built on docopts and expect and requires both of those programs to be installed as well as Bash 4.0 or newer.\nThis is the usage pattern for ccli:\nccli algorithm [options] [--] &lt;file&gt;...\nwhere algorithm is one of bktdsat, dsatur, greedy, itrgreedy, maxis or tabu. The options list allows us to specify any of the same options that we would specify with the interactive interface. For example, to use the embedded cheats we add the --cheat switch to the options list. For a full explanation of all options, consult the online documentation of ccli (ccli --help).\nFor example, to use ccli to colour the Chvatal graph file above with the greedy algorithm of simple type with inorder vertex ordering we call ccli like so:\nccli greedy --type=simple --ordering=inorder chvatal.res\nOptions that are not explicitly specified on the command-line default to values which can be seen in the usage documentation (ccli --help). For example, the default for --cheat is for it to be disabled.\nAs before, the colouring output of this call is augmented to the chvatal.col.res file. Future versions of ccli will support output to the standard output which will allow ccli to be used in the manner of other Unix programs discussed above."
  },
  {
    "objectID": "posts/2014-05-23-introduction-to-greedy-colouring/index.html#bounds-for-the-chromatic-number",
    "href": "posts/2014-05-23-introduction-to-greedy-colouring/index.html#bounds-for-the-chromatic-number",
    "title": "Introduction to Greedy Colouring",
    "section": "Bounds for the Chromatic Number",
    "text": "Bounds for the Chromatic Number\nThe greedy algorithm, both in theory and practice, is a useful tool for bounding the chromatic number of graphs. For if we have a colouring of a graph with \\(k\\) colours then we know that the chromatic number of that graph is at most \\(k\\).\nImagine that we have used greedy many times to produce a file a.dimacs.res which contains many different colourings of the graph a.dimacs. Then we can use a sed one-liner to extract the number of colours used by each colouring and put the results into a file.\n$ sed -n `s/CLRS \\([0-9]+\\) [A-Z a-z = 0-9 .]*/\\1/p` a.dimacs &gt; output.txt\nNow output.txt should contain several lines, each containing a single integer, the number of colours used in the corresponding colouring. To find the smallest of these values is just a matter of sorting the file numerically and reading the value in the first line. We put this number into a file for later inspection.\n$ sort -n output.txt | head -n 1 &gt; approx.txt\nNow the file approx.txt contains a our best estimate for the chromatic number.\nUsing these little hacks we can devise a simple scheme to use ccli to estimate the chromatic number of a graph.\n\nGenerate a large number of different colourings,\nFor each colouring, compute the colouring number,\nFind the smallest colouring number over all colourings,\nRecord this value as an approximation to the chromatic number.\n\nIf the colourings that we generate are all the same colouring then all of the numbers are the same. If we use Culberson’s programs in a deterministic way then we can only hope to generate a number of colourings equal to the number of combinations of algorithm and vertex orderings. Fortunately, the non-deterministic features of these programs give us the chance to generate a lot of different colourings and hopefully come up with better approximations.\nThe design of ccli makes it very easy to generate a lot of colourings from the shell. We simply write a loop:\n!#/bin/bash\nfor (( i=1; i&lt;=$1; ++i ))\ndo\n ccli greedy --type=$2 --ordering=$3 --seed=$RANDOM $4\ndone\nThis loop has been written in the form of a script which takes four parameters. The first is a number of iterations, the second is the algorithm type, third is the vertex ordering and the fourth is the path to the graph in DIMACS format. The $RANDOM variable is a Linux environment variable which generates a random integer and we this used to seed the random number generator in the greedy program. This means that each iteration produces a different colouring."
  },
  {
    "objectID": "posts/2014-05-23-introduction-to-greedy-colouring/index.html#bounds-for-the-chromatic-number-of-queen-graphs",
    "href": "posts/2014-05-23-introduction-to-greedy-colouring/index.html#bounds-for-the-chromatic-number-of-queen-graphs",
    "title": "Introduction to Greedy Colouring",
    "section": "Bounds for the Chromatic Number of Queen Graphs",
    "text": "Bounds for the Chromatic Number of Queen Graphs\nWe have applied the above scheme to queen graphs A queen graph is a graph whose vertices are the squares of a chessboard and edges join squares if and only if queens placed on those squares attack each other.\nThe chromatic number of queen graphs is still an open problem in general. According to the Online Encyclopedia of Integer Sequences the chromatic number of the queen graph of size 26 is unknown. Chvatal claims that in 2005 a 26-colouring of the queen graph of dimension 26 was found and thus 27 is the smallest unknown order. This follows because the chromatic number of a \\(n \\times n\\) queen graph is at least \\(n\\) and thus a 26-colouring of the \\(26 \\times 26\\) queen graph proves that the chromatic number is 26.\nIn the table below we list graphs from Michael Trick’s colouring instances page In the first column is the chromatic number, if known. Subsequent columns give approximations based on different parameters for greedy. The parameters are described in the list below the table.\nThe final column is the quality of the approximation, given by the ratio of the least colouring number over all colourings \\(\\chi_{a}\\) to the chromatic number \\(\\chi\\).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFilename\n\\(\\chi\\)\n1\n2\n3\n4\n5\n6\n7\n8\n9\nX\n\\(\\frac{\\chi_{a}}{\\chi}\\)\n\n\n\n\nqueen5_5.col\n5\n5\n-\n-\n-\n-\n-\n-\n-\n-\n-\n1.000\n\n\nqueen6_6.col\n7\n8\n8\n8\n8\n8\n7\n-\n-\n-\n-\n1.000\n\n\nqueen7_7.col\n7\n9\n9\n9\n9\n9\n9\n10\n10\n9\n8\n1.143\n\n\nqueen8_8.col\n9\n11\n11\n11\n11\n11\n10\n11\n11\n11\n11\n1.111\n\n\nqueen9_9.col\n10\n13\n12\n12\n12\n12\n12\n13\n12\n12\n12\n1.200\n\n\nqueen10_10.col\n11\n14\n14\n14\n14\n14\n13\n13\n14\n14\n14\n1.182\n\n\nqueen11_11.col\n11\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n1.364\n\n\nqueen12_12.col\n12\n17\n17\n17\n16\n16\n16\n16\n16\n16\n17\n1.333\n\n\nqueen13_13.col\n13\n19\n18\n18\n18\n18\n17\n18\n18\n18\n18\n1.308\n\n\nqueen14_14.col\n14\n20\n20\n19\n19\n19\n19\n19\n19\n19\n20\n1.357\n\n\nqueen15_15.col\n15\n21\n21\n21\n20\n20\n20\n20\n21\n21\n21\n1.333\n\n\nqueen16_16.col\n16\n23\n23\n22\n21\n22\n21\n21\n22\n22\n22\n1.312\n\n\n\nThe columns in the above table refer to the following parameter settings:\n\n--type=random --ordering=random (iterations 500)\n--type=random --ordering=random (iterations 1000)\n--type=random --ordering=random (iterations 5000)\n--type=simple --ordering=random (iterations 500)\n--type=simple --ordering=random (iterations 1000)\n--type=simple --ordering=random (iterations 5000)\n--type=simple --ordering=lbfsr (iterations 500)\n--type=simple --ordering=lbfsr (iterations 1000)\n--type=simple --ordering=lbfsr (iterations 5000) X. --type=random --ordering=lbfsd (iterations 10000)"
  },
  {
    "objectID": "posts/2014-08-15-colouring-small-regular-graphs/index.html",
    "href": "posts/2014-08-15-colouring-small-regular-graphs/index.html",
    "title": "Colouring Small Regular Graphs",
    "section": "",
    "text": "In this post we present two tables of data on chromatic numbers of [regular graphs][def:regular-graph]. Both tables give chromatic numbers of simple graphs on at most ten vertices. The first table shows the distribution of chromatic numbers over all regular simple graphs on at most ten vertices. The second table gives the distribution of chromatic numbers over all connected regular simple graphs on at most ten vertices. In this post we describe how this data was generated."
  },
  {
    "objectID": "posts/2014-08-15-colouring-small-regular-graphs/index.html#overview",
    "href": "posts/2014-08-15-colouring-small-regular-graphs/index.html#overview",
    "title": "Colouring Small Regular Graphs",
    "section": "Overview",
    "text": "Overview\nThe method used to generate the tables is the same method using in Colouring Small Graphs except that we use geng from the gtools collection of programs from the nauty package of Brendan McKay to generate the graph data, rather than download it from McKay’s webpage. This small change has the benefit that we can now run our simulation without an internet connection. The potential disadvantage of the extra dependency on nauty is not a new disadvantage because we were already using the listg program from gtools to convert data from graph6 to DOT format.\nAs the method we use is almost identical to the method of Colouring Small Graphs we don’t consider all of the details again here. Instead, we will describe only the differences. These are\n\nusing geng to generate regular graphs of order at most 10,\nsplitting DOT data across multiple files using a Drake rule,\ntaking a little extra care to collect chromatic numbers using grep.\n\nEach of these small changes is discussed in detail in the following three sections. After that, we present the data itself. The source code for the entire simulation can be downloaded as a Drakefile at the bottom of the post."
  },
  {
    "objectID": "posts/2014-08-15-colouring-small-regular-graphs/index.html#generating-regular-graphs",
    "href": "posts/2014-08-15-colouring-small-regular-graphs/index.html#generating-regular-graphs",
    "title": "Colouring Small Regular Graphs",
    "section": "Generating Regular Graphs",
    "text": "Generating Regular Graphs\nThe small graph data available on Brendan McKay’s webpage can also be generated using the geng program.\nThe most basic usage pattern for geng is geng n where n is the order of graphs to be generated. The output is a listing of all graphs of order n with one graph per line in graph6 format.\n$ geng 2\n&gt;A geng -d0D1 n=2 e=0-1\nA?\nA_\n&gt;Z 2 graphs generated in 0.00 sec\nNotice that the geng 2 command was expanded automatically to geng -d0D1 n=2 e=0-1. The first and last lines here can be suppressed using the -q switch.\n$ geng -q 2\nA?\nA_\nNow this can be piped into listg -y (we can also do the piping before suppressing the auxiliary data) to convert the output graph data to DOT format.\n$ geng -q 2 | listg -y\ngraph G1 {\n}\ngraph G2 {\n0--1;\n}\nThe expanded call to geng which was generated automatically above is the clue to how we can use geng to generate regular graphs. Optional switches of the form -d# and -D# allow bounds on, respectively, the minimum and maximum degree to be specified. -d0D1 says that the minimum degree should be zero and the maximum degree should be 1. So, for example, to generate all 1-regular graphs on three vertices:\n$ geng -q -d1D1 3\n&gt;E geng: impossible mine,maxe,mindeg,maxdeg values\n&gt;E Usage: geng [-cCmtfbd#D#] [-uygsnh] [-lvq]\n              [-x#X#] n [mine[:maxe]] [res/mod] [file]\n   Use geng -help to see more detailed instructions.\nThe error message here is no surprise. After all, there are no 1-regular graphs of order three. This reminds us that for regular graphs of odd degree we must have an even number of vertices (because the total degree \\(2m\\) of a graph with \\(m\\) edges is even).\n$ geng -q -d1D1 4 | listg -y\ngraph G1 {\n0--2;\n1--3;\n}\nIn this case there is only one graph because geng only generates non-isomorphic graphs.\nThe only other consideration we must be aware of is that if a graph is \\(k\\)-regular then, because \\(\\Delta(G) \\leq n - 1\\), it must have at least \\(k + 1\\) vertices. So, for example, the generate all 3-regular graphs on at most ten vertices in graph6 format:\n$ seq 4 2 10 | xargs -L1 geng -q -d3D3\nC~\nEFz_\nEUxo\nG?zTb_\nGCrb`o\nGCZJd_\nGCXmd_\nGCY^B_\nGQhTQg\nI?BeeOwM?\nI?Bcu`gM?\nI?bFB_wF?\nI?bEHow[?\nI?`bfAWF?\nI?`cu`oJ?\nI?`cspoX?\nI?`bM_we?\nI?`cm`gM?\nI?`cmPoM?\nI?`amQoM?\nI?`c]`oM?\nI?aKZ`o[?\nICOfBaKF?\nICOf@pSb?\nICOef?kF?\nICOedPKL?\nICOedO[X?\nICQRD_kQ_\nICQRD_iR?\nICQRChgI_\nPiping this output (not shown) into listg -y then generates a listing of the same graphs in DOT format."
  },
  {
    "objectID": "posts/2014-08-15-colouring-small-regular-graphs/index.html#splitting-graph-data",
    "href": "posts/2014-08-15-colouring-small-regular-graphs/index.html#splitting-graph-data",
    "title": "Colouring Small Regular Graphs",
    "section": "Splitting Graph Data",
    "text": "Splitting Graph Data\nAs before we split the resulting DOT format graph data across a folder of multiple files, one per graph. In the last post we did this outside of the Drakefile. Now, because we are generating all the graph data we use, we are forced to do the splitting with Drake.\nThis involves a Drake method split()\nsplit()\n  mkdir -p $OUTPUT\n  csplit -sz -b '%d.gv' -f$OUTPUT/ $INPUT '/^graph.*/' '{*}'\nand rules for each degree. For example, to generate the folder data/1r_gv_split from the DOT file of 1-regular graphs data/1r_gv:\ndata/1r_gv_split &lt;- data/1r_gv [method:split]\nThe csplit invocation is exactly the same as before. The only difference in the method is that before splitting we create the output folder, if it doesn’t already exist."
  },
  {
    "objectID": "posts/2014-08-15-colouring-small-regular-graphs/index.html#collecting-chromatic-numbers",
    "href": "posts/2014-08-15-colouring-small-regular-graphs/index.html#collecting-chromatic-numbers",
    "title": "Colouring Small Regular Graphs",
    "section": "Collecting Chromatic Numbers",
    "text": "Collecting Chromatic Numbers\nWith the graph data now built we iterate as before over all graphs, collecting their chromatic numbers. However, now because we are considering graphs of orders up to 10 there is a possibility of chromatic number 10. This means that we have to be a little bit more careful when it comes to using grep to make sure that we count occurrences of chromatic numbers correctly. Where we had been using\ngrep -c $j $INPUT\nnow we use:\ngrep -Fcx $j $INPUT\nThe -F switch here ensures that $j is considered as an entire string for matching. So, for example, if $j=10 the grep searches for occurrences of the sequence 10 not occurrences of 1 or 0. The -x switch ensures, additionally, that only exact matches are counted. For example, if 10 occurs in a longer string, 110 say, then grep won’t count this."
  },
  {
    "objectID": "posts/2014-08-15-colouring-small-regular-graphs/index.html#results",
    "href": "posts/2014-08-15-colouring-small-regular-graphs/index.html#results",
    "title": "Colouring Small Regular Graphs",
    "section": "Results",
    "text": "Results\nWith all of the above considerations we found the following data for regular simple graphs on at most 10 vertices, including disconnected graphs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\[\\chi = 1\\]\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\\[k = 1\\]\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n2\n5\n6\n4\n2\n1\n0\n0\n0\n0\n\n\n3\n0\n13\n22\n42\n6\n2\n0\n0\n0\n\n\n4\n0\n0\n4\n40\n53\n11\n1\n0\n0\n\n\n5\n0\n0\n0\n2\n3\n13\n3\n1\n0\n\n\n6\n0\n0\n0\n0\n1\n0\n1\n0\n0\n\n\n7\n0\n0\n0\n0\n0\n1\n0\n0\n0\n\n\n8\n0\n0\n0\n0\n0\n0\n1\n0\n0\n\n\n9\n0\n0\n0\n0\n0\n0\n0\n1\n0\n\n\n10\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\nTotal:\n5\n19\n30\n86\n64\n27\n6\n2\n1\n\n\n\nThe data for connected regular simple graphs on at most 10 vertices is as follows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\[\\chi = 1\\]\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\\[k = 1\\]\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n2\n1\n4\n4\n2\n1\n0\n0\n0\n0\n\n\n3\n0\n4\n22\n42\n6\n2\n0\n0\n0\n\n\n4\n0\n0\n1\n40\n53\n11\n1\n0\n0\n\n\n5\n0\n0\n0\n1\n3\n13\n3\n1\n0\n\n\n6\n0\n0\n0\n0\n1\n0\n1\n0\n0\n\n\n7\n0\n0\n0\n0\n0\n1\n0\n0\n0\n\n\n8\n0\n0\n0\n0\n0\n0\n1\n0\n0\n\n\n9\n0\n0\n0\n0\n0\n0\n0\n1\n0\n\n\n10\n0\n0\n0\n0\n0\n0\n0\n0\n1\n\n\nTotal:\n1\n8\n27\n85\n64\n27\n6\n2\n1"
  },
  {
    "objectID": "posts/2014-08-15-colouring-small-regular-graphs/index.html#conclusions",
    "href": "posts/2014-08-15-colouring-small-regular-graphs/index.html#conclusions",
    "title": "Colouring Small Regular Graphs",
    "section": "Conclusions",
    "text": "Conclusions\nAt this point we haven’t given much (any?) consideration about the veracity of the above data. There is a certain degree of confidence in using a method which has been used before to generate chromatic numbers of graphs that can be verified against an existing, independent computation.\nWe can at least be fairly confident about the generated graph data, for a couple of reasons. Firstly, to generate the data we used a fairly trivial application of reliable graph generating software. Additionally, at least in the connected case, we can compare at least the total number of graphs of each degree against a independent computation of Markus Meringer.\nIn the future we will revisit the above data and consider how we might add some verification steps. There are bounds for the chromatic number of regular graphs and results like the following one of “Regular Graphs with Prescribed Chromatic Number - Caccetta - 1990 - Journal of Graph Theory - Wiley Online Library” (n.d.) have some potential in this regard.\nTheorem\nIf \\(k &gt; 1\\), then for every \\(n \\geq \\lceil\\frac{5k}{3}\\rceil\\) there is a connected, regular, \\(k\\)-chromatic graph on \\(n\\) vertices.\nOne approach would be the generalise our method to graphs of greater order. The Drakefile, as it stands, is not straightforward to extend in this regard."
  },
  {
    "objectID": "posts/2014-08-22-small-moore-graphs/index.html",
    "href": "posts/2014-08-22-small-moore-graphs/index.html",
    "title": "Small Moore Graphs",
    "section": "",
    "text": "With geng we can generate graphs in graph6 format. For example, to generate all connected simple graphs of order four:\nHere, the -q switch suppresses some auxilliary output and -c specifies connected graphs.\nWe can specify a class of graphs having certain properties, such as size, degree bounds, existence of cycles, connectedness or bipartiteness. For example, to generate all connected, bipartite graphs of order four with maximum degree two:\nWe can visualise these graphs using listg to convert the output to DOT format and the using one of the Graphviz programs to draw them. If we have many options to pass to the drawing program it makes sense to pack them all into a variable for future use.\nThese two graphs answer a very easy conjecture about the existence of graphs having the following properties:\nMany problems in graph theory can be expressed as the existence of graphs satisfying a list of properties like this. The existence of Moore graphs, for example, is a problem yet to be completely resolved which takes this simple form. So it might be nice to have a little program moore, that filters Moore graphs from the output of geng.\nThen if we should wish, for example, to draw all Moore graphs on five vertices we can modify the above pipeline accordingly:\nIn this post we show how to program such a filter in Bash and Maxima, albeit one which is fatally flawed."
  },
  {
    "objectID": "posts/2014-08-22-small-moore-graphs/index.html#moore-graphs",
    "href": "posts/2014-08-22-small-moore-graphs/index.html#moore-graphs",
    "title": "Small Moore Graphs",
    "section": "Moore Graphs",
    "text": "Moore Graphs\nA Moore graph is a graph with diameter \\(d\\) and maximum degree \\(k\\) which has the maximum number of vertices for a graph with the same diameter and maximum degree.\nIn Cameron (1994) it is shown that a Moore graph is any graph satisfying the following conditions (any two of which imply the third):\n\n\\(G\\) is connected with maximum degree \\(k\\) and diameter \\(d\\);\n\\(G\\) has minimum degree \\(k\\) and girth \\(2d + 1\\);\n\\(G\\) has \\(1 + k\\frac{(k - 1)^{d} - 1}{k - 2}\\) vertices.\n\nIf the output from the pipeline at the end of the previous section is correct then there are only two Moore graphs of order five, \\(K_{5}\\) and \\(C_{5}\\).\n\n\\(d = 1\\). \\(K_{n}\\) and \\(C_{3}\\) are the only Moore graphs.\n\\(d = 2\\). The Hoffman-Singleton theorem says that a Moore graph must have \\(k \\in \\{2, 3, 7, 57\\}\\).\n\n\\(k = 2\\) the unique Moore graph is \\(C_{5}\\).\n\\(k = 3\\) the unique Moore graph is the Petersen graph.\n\\(k = 7\\) the unique Moore graph is the Hoffman-Singleton graph (shown below).\n\\(k = 57\\) unknown whether there exists a hypothetical Moore graph which would necessarily have girth 5 and order 3250.\n\n\\(d \\geq 3\\). According to Damerell (1973) and Bannai and Ito (1973) the only Moore graphs is \\(C_{2d + 1}\\).\n\nTo draw the Hoffmann-Singleton graph:\n$ curl http://staffhome.ecm.uwa.edu.au/~00013890/remote/cages/cagesk7g05.s6\\\n  | listg -y\\\n  | circo -Tsvg -O $options\n\n\n\nHoffmann-Singleton Graph"
  },
  {
    "objectID": "posts/2014-08-22-small-moore-graphs/index.html#processing-graph-data-with-maxima",
    "href": "posts/2014-08-22-small-moore-graphs/index.html#processing-graph-data-with-maxima",
    "title": "Small Moore Graphs",
    "section": "Processing Graph Data with Maxima",
    "text": "Processing Graph Data with Maxima\nThe three conditions in the previous section form the basis of the Moore graph filter below. By itself we can’t use geng to identify Moore graphs because any two of these conditions involve computing either the girth or diameter.\nMaxima, the computer algebra system, has a graphs library which includes functions that compute the girth and diameter of graphs. Even better, it also provides conversion to and from graph6 format.\nBecause the program we are going to write is supposed to work within a pipeline we will use Maxima in batch mode, rather than interactively. To avoid working with multiple source files we will use the --batch-string option to pass a program to Maxima as a string.\nOne drawback with Maxima is that there is a little bit of processing to be done one the output of any program because, even running in batch mode with minimal verbosity, Maxima still outputs a lot of extraneous text.\nAs the basic structure of the program is relatively complicated we will begin with an example. This example also serves to highlight an important consideration when it comes to the speed of the program.\nIn the listing below is a Bash program that calculates the degree of every graph in an input string of whitespace-delimited graphs in graph6 format.\n#!/bin/bash\n\nwhile read\ndo\n s=\"\n load(graphs)$\n g: graph6_decode(\\\"$REPLY\\\")$\n graph_size(g);\n \"\n maxima --very-quiet --batch-string=\"$s\"\\\n  | tail -n 1\\\n  | tr -d ' \\t\\r\\f[]'\\\n  | tr ',' '\\n'\ndone\nUnfortunately, this approach is incredibly slow for at least two obvious reasons. The first is that for every graph we run a new instance of Maxima. The second is that each of these many instances of Maxima has to import the graphs library.\nA different approach, which is much faster, is to read the entire list of graphs as a string, convert that string into the string representation of a Maxima list of strings and hand that to one instance of Maxima to process. The following listing does just that.\n#!/bin/bash\n\nread g6raw\ng6proc=$(echo $g6raw |\n         awk '{  print \"\\\"\" $1 \"\\\"\" \",\" }' RS=' ' ORS=' ' |\n         sed '$s/. $//')\ng6list=\"[\"${g6proc}\"]\"\n\ns=\"\nload(graphs)$\n\ng6list: $g6list$\nglist: map(graph6_decode, g6list)$\nl:map(graph_size, glist)$\nprintf(true, \\\"~{~a,~}\\\", l);\n\"\n\nmaxima -q --very-quiet --batch-string=\"$s\"\\\n | tail -n 1\\\n | tr -d ' \\t\\r\\f'\\\n | tr ',' '\\n'\\\n | head -n -1\nThis approach presents some new problems. Firstly, because we read the entire output of geng into one string we have to use echo geng. A worse problem is that we quickly run out of memory, even for very small values of the graph order. Nevertheless, for the sake of experimentation, we continue with this approach for the Moore graphs application. In the worst case it will make a reasonable base for future development."
  },
  {
    "objectID": "posts/2014-08-22-small-moore-graphs/index.html#filtering-moore-graphs",
    "href": "posts/2014-08-22-small-moore-graphs/index.html#filtering-moore-graphs",
    "title": "Small Moore Graphs",
    "section": "Filtering Moore Graphs",
    "text": "Filtering Moore Graphs\nAssuming that input is a string of whitespace-delimited graphs in graph6 format we start by building a Bash string representing a Maxima list of the same graph6 format strings.\nread g6raw\ng6proc=$(echo $g6raw |\n         awk '{  print \"\\\"\" $1 \"\\\"\" \",\" }' RS=' ' ORS=' ' |\n         sed '$s/. $//')\ng6list=\"[\"${g6proc}\"]\"\nThe AWK program here surrounds all strings with double-quotes and adds a separating comma. The Sed hack removes the last comma and the final assignment statement puts the entire list of strings into a string surrounded by a pair of square braces, the Maxima syntax for a list.\nNow we have the data in a format that can be passed to Maxima we build the entire Maxima program as a Bash string. The core of the program is a function moore1(G) which decides whether the graph G is a Moore graph or not.\nmoore1(G):=\n (\n  K: max_degree(G)[1],\n  k: min_degree(G)[1],\n  d: diameter(G),\n  g: girth(G),\n  is_connected(G) and is(g = 2*d + 1 and k = K)\n )$\nHere max_degree, min_degree, diameter, girth and is_connected are all functions from the Maxima graphs library. The is function is one of the core Maxima functions for Boolean predicate testing.\nThe function moore1(G) has no return statement because Maxima functions which are made up from a simple list of statements in this way return the last evaluated value by default.\nFor comparision, although not discussed further here, we also implemented another two functions for testing whether a graph is a Moore graph or not. These are based on the remaining two ways of choosing a pair of conditions from the list above.\nmoore2(g):=\n (\n  k: max_degree(g)[1],\n  d: diameter(g),\n  expected_order: 1 + k*(((k - 1)^d - 1)/(k - 2)),\n  is_connected(G) and is(graph_order(g) = expected_order)\n )$\n\nmoore3(g):=\n (\n  k: min_degree(g)[1],\n  d: (girth(g) - 1)/2,\n  expected_order: 1 + k*(((k - 1)^d - 1)/(k - 2)),\n  is(graph_order(g) = expected_order)\n )$\nWith the testing function implemented we turn to the graphs library and its graph6_encode and graph6_decode functions to convert the incoming data and the outgoing results.\ng6list: $g6list$\nglist: map(graph6_decode, g6list)$\nmoore_graphs: sublist(glist, moore1)$\nmap(graph6_encode, moore_graphs);\nAll of the above code is the content of a Bash string which is handed to Maxima for batch processing. This approach makes it easy, e.g g6list: $g6list to pass data from Bash to Maxima. After the Maxima program has finished we need to use tail and tr to clean up the output so that we only see the graph data and none of the auxilliary output of Maxima.\nmaxima --very-quiet --batch-string=\"$s\"\\\n  | tail -n 1\\\n  | tr -d ' \\t\\r\\f[]'\\\n  | tr ',' '\\n'\nIn its present state the final script correctly identifies the Moore graphs on at most six vertices. With some improvement we hope to extend this to graphs of order at most nine."
  },
  {
    "objectID": "posts/2014-06-06-processing-graph-streams/index.html",
    "href": "posts/2014-06-06-processing-graph-streams/index.html",
    "title": "Processing Graph Streams",
    "section": "",
    "text": "In this post we introduce gvpr a graph stream editor which belongs to the Graphviz software library. As this is our first post about Graphviz and gvpr is, perhaps, not the most obvious place to start we will begin this post with a demonstration of another program from Graphviz, gc. After that we will introduce gvpr and show how gc can be implemented in gvpr.\nOur main interest in gvpr is related to last week’s post in which we were faced with the problem of applying a colouring found by Culberson’s colouring programs to a file containing graph data in DOT format. In that post we found an ad-hoc solution based on a Bash script and Sed. The approach we use here, based on gvpr, is much nicer but still might not be the best possible solution."
  },
  {
    "objectID": "posts/2014-06-06-processing-graph-streams/index.html#implementing-gc-in-gvpr",
    "href": "posts/2014-06-06-processing-graph-streams/index.html#implementing-gc-in-gvpr",
    "title": "Processing Graph Streams",
    "section": "Implementing gc in gvpr",
    "text": "Implementing gc in gvpr\nThere are several simple examples of programs written in gvpr in the gvpr manual. One of those programs is the following gc-like program implementation. As an introduction to gvpr, in this section we will explain how this program works. The entire source code is shown below.\nBEGIN { int n, e; int tot_n = 0; int tot_e = 0;}\nBEG_G {\n n = nNodes($G);\n e = nEdges($G);\n printf(\"%d nodes %d edges %s\\n\", n, e, $G.name);\n tot_n += n;\n tot_e += e;\n}\nEND { printf(\"%d nodes %d edges total\\n\", tot_n, tot_e) }\nIf the above code is in a file called gv and that file is located in a folder on one of the paths in the GPRPATH environment variable then we can invoke it in by calling gvpr with the filename gv as the argument of the -f switch.\n$ curl -s https://raw.githubusercontent.com/MHenderson/graphs-collection/master/src/Classic/Tutte/tutte.gv\\\n  https://raw.githubusercontent.com/MHenderson/graphs-collection/master/src/Classic/Frucht/frucht.gv\\\n  https://raw.githubusercontent.com/MHenderson/graphs-collection/master/src/Classic/Heawood/heawood.gv\\\n  | gvpr -fgc\n46 nodes 69 edges %1\n12 nodes 18 edges %141\n14 nodes 21 edges %179\n72 nodes 108 edges total\nThe program works in the following way. gvpr processes the input graphs one at a time. Before doing any processing, though, it calls the action of the BEGIN clause. For our program this merely has the effect of initialising some variables we will use to count edges and vertices.\nNow gvpr moves onto processing the first graph. Once it has processed the first graph it moves onto the second, and so on, until the last graph has been processed at which point it calls the action of the END clause. In our gc program this prints out the total number of edges and vertices over all of the graphs.\nWhen gvpr processes each graph it first sets the variable $ to the current graph and then it calls the action of the BEGIN_G clause. It will then do some processing of nodes and edges (explained in the next paragraph) before calling the action of the END_G clause after each graph. In our case, when a graph is processed by gvpr we count the number of edges and vertices, print those numbers out and add them to the total edge and vertex count.\nThe innermost processing that gvpr does is to consider every node and edge. Any number of N and E clauses can be implemented to create some specific behaviours at nodes and edges. For example, we might provide actions to weight a node or edge with a particular value or other or we might set attributes, like the position of a vertex according to the result of a layout algorithm.\nThe N and E clauses both support predicate-action pairs. This means that the action will only be run if the predicate belonging to the predicate-action pair is satisfied as well as the main N or E clause (which is only true when we have encountered a node or edge).\nN [ predicate ]{ action }\nE [ predicate ]{ action }\nIn the next section we consider a different application of gvpr. We show how it can be used to take the output of a colouring from ccli and apply it to the vertices of a graph which can then be passed to one of the layout programs for drawing."
  },
  {
    "objectID": "posts/2014-06-06-processing-graph-streams/index.html#colouring-vertices-with-gvpr",
    "href": "posts/2014-06-06-processing-graph-streams/index.html#colouring-vertices-with-gvpr",
    "title": "Processing Graph Streams",
    "section": "Colouring Vertices with gvpr",
    "text": "Colouring Vertices with gvpr\nOur implementation of applying a colouring to a graph in DOT format in gvpr is just three lines of code.\nBEG_G { setDflt($, \"N\", 'colorscheme', 'set13') }\nN { aset($, 'style', 'filled') }\nN { aset($, 'color', ARGV[$.name]) }\nThe basic structure is familiar from the gc-like implementation above. We have three clauses, a BEG_G clause and two N clauses. The action for each clause is a call to one of two different functions setDflt and aset.\nThe setDflt function sets the default value of an attribute . As we call this function in the body of the BEG_G clause the built-in variable $ is set to the current graph. In this case we are setting the default value of the colorscheme attribute for nodes to the set13 colour scheme. Graphviz provides several different colour schemes. The following quotation from the gvpr manual explains how colour schemes work.\n\nThis attribute specifies a color scheme namespace. If defined, it specifies the context for interpreting color names. In particular, if a color value has form “xxx” or “//xxx”, then the color xxx will be evaluated according to the current color scheme. If no color scheme is set, the standard X11 naming is used. For example, if colorscheme=bugn9, then color=7 is interpreted as “/bugn9/7”.\n\nThe aset function sets the value of an attribute. As we use the aset function in the body of actions that belong to N clauses we are going to be setting attributes of nodes. When gvpr is processing nodes is assigns the current node to the built-in variable $. So the syntax aset($, x, y) assigns the value y to the attribute x.\nWe set two attributes for every node. We set the style attribute to filled so that when the output graph is rendered by one of the drawing programs in Graphviz the nodes will be drawn as filled-in shapes, making the colour visible. The other attribute we set for each node is the color. In this case, the color is set to a value which is determined by the corresponding value of ARGV.\nTo use our program, call gvpr with the colour program as the argument of the -f switch. Then to provide the vertex colouring we pass a string to gvpr as the argument of the -a switch (this is then available inside of a gvpr program as the value of the ARGV variable.\ngvpr -f colour -a '1 2 3 1 2 3 2 3 1 3 1 2' frucht.gv &gt; frucht.gv.col\nNow we can combine the colouring with drawing by the twopi program.\ngvpr -c -f colour -a '1 2 3 1 2 3 2 3 1 3 1 2' frucht.gv |\\\ntwopi -s\\\n      -Tsvg\\\n      -Gsize=4,4\\!\\\n      -Groot=3\\\n      -Nwidth=0.3\\\n      -Nfixedsize=true\\\n      -Nlabel=\\\n      -Nshape=circle\\\n      -o frucht.svg\nThe resulting drawing with coloured nodes looks like this:\n\n\n\nDrawing of the Frucht graph."
  },
  {
    "objectID": "posts/2014-06-06-processing-graph-streams/index.html#references",
    "href": "posts/2014-06-06-processing-graph-streams/index.html#references",
    "title": "Processing Graph Streams",
    "section": "References",
    "text": "References\nFor more information about gvpr, a good reference is the man documentation."
  },
  {
    "objectID": "posts/2014-09-12-more-on-moore-graphs/index.html",
    "href": "posts/2014-09-12-more-on-moore-graphs/index.html",
    "title": "More on Moore Graphs",
    "section": "",
    "text": "In Small Moore Graphs we developed moore, a filter for Moore graphs in graph6 format. The virtue of a program like moore is that it can be used in pipelines with existing programs to create new programs, as demonstrated in that earlier post.\nIn its present form (at time of writing) moore filters Moore graphs from a string of whitespace delimited graphs in graph6 format. So, to use it in a pipeline we have to ensure that the input is a single string, rather than raw standard input:\nBeyond this small design flaw, moore has a few other, as yet unresolved, issues. For example, it fails to filter the Moore graphs of order seven from a string of all non-isomorphic connected graphs on seven vertices.\nRather than fix these problems immediately, in this post, we build an alternative implementation of the same program. Before, with moore we used Bash and Maxima. Here we will Python with both the NetworkX and igraph packages. The former for its graph6 handling and the latter for degree, girth and diameter calculations."
  },
  {
    "objectID": "posts/2014-09-12-more-on-moore-graphs/index.html#iterating-over-graphs-with-python",
    "href": "posts/2014-09-12-more-on-moore-graphs/index.html#iterating-over-graphs-with-python",
    "title": "More on Moore Graphs",
    "section": "Iterating Over Graphs with Python",
    "text": "Iterating Over Graphs with Python\nThe resulting program, moore.py will read graphs in graph6 format from standard input and echo back those graphs which are Moore graphs.\nOne approach to working with standard input in Python is to use the stdin object from the sys module of the standard library. The stdin object has a readlines method that makes iterating over lines of standard input as simple as:\nfrom sys import stdin\n\nfor line in stdin.readlines():\n    # Do something\nWe will expect here that each line is a graph6 format string. Inside the body of the loop we then need to do the following three things:\n\nparse the graph6 string into a graph object G,\ncheck if G is Moore graph or not and, if it is,\necho the original input line on standard output.\n\nThe first of these steps can be handled by the parse_graph6 function from NetworkX. The only processing we do on each line is to strip whitespace on the right using the rstrip string method.\nThe result of parsing is a networkx.Graph object g. As NetworkX does not implement girth computation we construct a second igraph.Graph object G from g.edges(), the list of edges of g.\nfrom sys import stdin\n\nfrom networkx import parse_graph6\n\nfrom igraph import Graph\n\nif __name__ == \"__main__\":\n    for line in stdin.readlines():\n        stripped_line = line.rstrip()\n        g = parse_graph6(stripped_line)\n        G = Graph(edges = g.edges())\n        moore = moore_gd\n        if moore(G):\n            print stripped_line\nTesting for Moore graphs is done by a function moore (here pointing to one of three alternative implementations moore_gd, moore_nd and moore_gn). In the next section these three different functions are described."
  },
  {
    "objectID": "posts/2014-09-12-more-on-moore-graphs/index.html#testing-moore-graphs",
    "href": "posts/2014-09-12-more-on-moore-graphs/index.html#testing-moore-graphs",
    "title": "More on Moore Graphs",
    "section": "Testing Moore Graphs",
    "text": "Testing Moore Graphs\nAs seen in Small Moore Graphs there are, at least, three different ways to test whether a graph is a Moore graph or not. Those three methods are based on a theorem from Cameron (1994) which says that a graph is a Moore graph if it satisfies any two of the following three conditions:\n\n\\(G\\) is connected with maximum degree \\(k\\) and diameter \\(d\\);\n\\(G\\) has minimum degree \\(k\\) and girth \\(2d + 1\\);\n\\(G\\) has \\(1 + k\\sum_{i=0}^{d-1}(k - 1)^{i}\\) vertices.\n\nThe third condition gives the maximum order of a \\(k\\)-regular graph with diameter \\(d\\). As this is a value we need in more than one place it gets its own function.\ndef moore_order(d, k):\n    \"\"\"\n    In a regular graph of degree k and diameter d the order is\n    at most moore_order(d, k).\n    \"\"\"\n    return 1 + k*sum([(k - 1)**i for i in range(d)])\nNow moore_gn, which is based on the combination of conditions 2 (involving girth) and 3 (involving order) above can be implemented for igraph.Graph objects as follows:\ndef moore_gn(G):\n  \"\"\"\n  Decide if G is a Moore graph or not, based on order and girth.\n  \"\"\"\n  return G.vcount() == moore_order((G.girth() - 1)/2, min(G.degree()))\nRemembering that every graph which satisfies conditions 2 and 3 above is also regular and connected might persuade us to consider some optimisations here. For example, as the minimum degree of vertices must be calculated we might as well also compute the maximum degree and avoid moore_order and girth calculations for any graph for which those values differ.\nSimilarly, we might also dismiss any graph which isn’t connected. Optimisations like these require some experimentation to determine their worth. Also, when programs like geng have already efficient ways to generated connected and regular graphs there will be circumstances when we only want the essential computation to be done. So at present we will concentrate on building a reliable implementation and leave such considerations for the future.\nWith disregard for optimisation in mind, the other testing functions based on the remaining combinations of conditions 1, 2 and 3. are also very simple one-liners. The girth and diameter variant looks like:\ndef moore_gd(G):\n  \"\"\"\n  Decide if G is a Moore graph or not, based on girth and diameter.\n  \"\"\"\n  return G.girth() == 2*G.diameter() + 1\nWhile the version based on order and diameter is:\ndef moore_nd(G):\n  \"\"\"\n  Decide if G is a Moore graph or not, based on order and diameter.\n  \"\"\"\n  return G.vcount() == moore_order(G.diameter(), max(G.degree()))"
  },
  {
    "objectID": "posts/2014-09-12-more-on-moore-graphs/index.html#results",
    "href": "posts/2014-09-12-more-on-moore-graphs/index.html#results",
    "title": "More on Moore Graphs",
    "section": "Results",
    "text": "Results\nNow we can construct all Moore graphs on at most 10 vertices in a single pipeline involving geng and moore.py. Here the resulting graphs are visualised with circo from Graphviz after conversion to DOT format using listg:\n$ options=\"-Gsize=5,5!\n           -Nfixedsize=true\n           -Nlabel=\n           -Nshape=circle\n           -Nheight=0.2\n           -Nwidth=0.2\n           -Nstyle=filled\n           -Nfillcolor=black\"\n\n$ seq 1 10\\\n  | xargs -L1 geng -qc\\\n  | moore.py\\\n  | listg -y\\\n  | circo -Tsvg -O $options"
  },
  {
    "objectID": "posts/2014-07-18-a-chromatic-number-program/index.html",
    "href": "posts/2014-07-18-a-chromatic-number-program/index.html",
    "title": "A Chromatic Number Program",
    "section": "",
    "text": "The chromatic polynomial \\(\\chi(G, \\lambda)\\) allows us to determine the chromatic number of \\(G\\) as \\(\\chi(G) = \\min\\{\\lambda \\in \\{1,\\ldots,\\Delta(G) + 1\\}\\,|\\, \\chi(G, \\lambda) &gt; 0\\}\\)\nComputationally, though, the chromatic polynomial is an expensive object to construct. However, we can still use this method to calculate the chromatic numbers of small graphs.\nIn this blog we try to find more than one method for every calculation and for every method we try to give more than one implementation. This is because, ultimately, we hope to have reliable, reproducible results. As far as reliability goes, redundancy in our data is important and so, for this reason, here we provide another implementation of the chromatic number based on the chromatic polynomial.\nIn the previous post we used exclusively NetworkX for the implementation. Here we use traditional GNU utilities like Sed, cat, tr and tail, the Graphviz program gvpr, the GNU Maxima computer algebra system and an implementation of the Tutte polynomial by Haggard, Pearce and Royle."
  },
  {
    "objectID": "posts/2014-07-18-a-chromatic-number-program/index.html#chromatic-numbers-of-small-dot-graphs",
    "href": "posts/2014-07-18-a-chromatic-number-program/index.html#chromatic-numbers-of-small-dot-graphs",
    "title": "A Chromatic Number Program",
    "section": "Chromatic Numbers of Small DOT Graphs",
    "text": "Chromatic Numbers of Small DOT Graphs\nOur program, which is little more than a wrapper script, takes as input a graph in DOT format and outputs the chromatic number. The program works by following the four steps below.\n\ncompute the maximum degree of the input graph,\nconvert the Graphviz data file into the input graph format used by the tutte program,\ncompute the chromatic polynomial using tutte,\ncompute the chromatic number using GNU Maxima.\n\nThe only non-trivial work here is done by the tutte and Maxima programs. Our script is simply a driver or wrapper providing a convenient interface. In fact, the dependency on GNU Maxima here could doubtless be removed because tutte is able to compute values of the polynomials it computes.\nIn a forthcoming post we will use the program described in this post to reproduce, and hopefully extend, the data from last week’s post on chromatic numbers of small graphs. In the rest of this post we describe each of the four steps above in detail."
  },
  {
    "objectID": "posts/2014-07-18-a-chromatic-number-program/index.html#maximum-degree-computation",
    "href": "posts/2014-07-18-a-chromatic-number-program/index.html#maximum-degree-computation",
    "title": "A Chromatic Number Program",
    "section": "Maximum Degree Computation",
    "text": "Maximum Degree Computation\nSome graph data formats include parameter data like number of vertices and number of edges. In this context we assume that we have a graph in DOT format without any additional parameter data. As it turns out, the tutte program infers the parameter data it needs from the graph input. So we are only left with need to calculate the maximum degree which is needed outside of tutte as the upper limit of the main loop.\nA gvpr program, maxdeg computes the maximum and minimum degree of graphs in DOT format.\n$ curl -s https://raw.githubusercontent.com/MHenderson/graphs-collection/master/src/Classic/Chvatal/chvatal.gv\\\n  | gvpr -f maxdeg\nmax degree = 4, node 0, min degree = 4, node 0\nTo use this program in our final pipeline we simply scrape out the maximum degree value from this output using Sed:\n$ ...\n  | sed -n 's/max degree = \\([0-9]*\\).*/\\1/p'\n4"
  },
  {
    "objectID": "posts/2014-07-18-a-chromatic-number-program/index.html#convert-graph-format",
    "href": "posts/2014-07-18-a-chromatic-number-program/index.html#convert-graph-format",
    "title": "A Chromatic Number Program",
    "section": "Convert Graph Format",
    "text": "Convert Graph Format\nThe input format for tutte is quite similar to the DOT format that we are using as the input format for our program. In the tutte format, edges are designated by a string of the form x--y and a graph is a comma separated list of edges.\nTo convert a graph in DOT format into the tutte input format can thus be accomplished by:\n\nmatching edges of the form x -- y; and replacing them with edges of the form x--y,,\nremoving all whitespace, including newlines,\nremoving the final, extraneous comma.\n\nA pipeline involving Sed and tr is by no means the only way to accomplish this sequence of replacements but suffices for our purposes.\n$ curl -s https://raw.githubusercontent.com/MHenderson/graphs-collection/master/src/Classic/Chvatal/chvatal.gv\\\n  | sed -n 's/\\([0-9]*\\) -- \\([0-9]*\\);/\\1--\\2,/p'\\\n  | tr -d ' \\t\\n\\r\\f'\\\n  | sed '$s/.$//'\n0--1,0--4,0--6,0--9,1--2,1--5,1--7,2--3,2--6,2--8,3--4,3--7,3--9,4--5,4--8,5--10,5--11,6--10,6--11,7--8,7--11,8--10,9--10,9--11"
  },
  {
    "objectID": "posts/2014-07-18-a-chromatic-number-program/index.html#compute-the-chromatic-polynomial",
    "href": "posts/2014-07-18-a-chromatic-number-program/index.html#compute-the-chromatic-polynomial",
    "title": "A Chromatic Number Program",
    "section": "Compute the Chromatic Polynomial",
    "text": "Compute the Chromatic Polynomial\nThere is almost nothing to this step. We simply call the tutte program on the data from the previous step and scrape the output for the polynomial string result.\nThe important options for tutte in this context are --stdin which tells tutte to expect input from standard input and --chromatic which asks for the chromatic, as opposed to Tutte, polynomial.\n$ curl -s https://raw.githubusercontent.com/MHenderson/graphs-collection/master/src/Classic/Chvatal/chvatal.gv\n  | sed -n -e 's/\\([0-9]*\\) -- \\([0-9]*\\);/\\1--\\2,/p'\n  | tr -d ' \\t\\n\\r\\f'| sed '$s/.$//'\n  | tutte --chromatic --stdin\nG[1] := {0--1,0--4,0--6,0--9,1--2,1--5,1--7,2--3,2--6,2--8,3--4,3--7,3--9,4--5,4--8,5--10,5--11,6--10,6--11,7--8,7--11,8--10,9--10,9--11}\nCP[1] := -1 * x * ( 1994*(1-x) + 7427*(1-x)^2 + 12339*(1-x)^3 + 12360*(1-x)^4 + 8445*(1-x)^5 + 4191*(1-x)^6 + 1559*(1-x)^7 + 438*(1-x)^8 + 91*(1-x)^9 + 13*(1-x)^10 + 1*(1-x)^11 ) :\nThe chromatic polynomial is everything between G[1] := and :. This delimitation makes extraction with Sed easy:\n$ ...\n  | sed -n 's/^CP\\[1\\] :=\\(.*\\) :/\\1/p'\n -1 * x * ( 1994*(1-x) + 7427*(1-x)^2 + 12339*(1-x)^3 + 12360*(1-x)^4 + 8445*(1-x)^5 + 4191*(1-x)^6 + 1559*(1-x)^7 + 438*(1-x)^8 + 91*(1-x)^9 + 13*(1-x)^10 + 1*(1-x)^11 )"
  },
  {
    "objectID": "posts/2014-07-18-a-chromatic-number-program/index.html#compute-the-chromatic-number",
    "href": "posts/2014-07-18-a-chromatic-number-program/index.html#compute-the-chromatic-number",
    "title": "A Chromatic Number Program",
    "section": "Compute the Chromatic Number",
    "text": "Compute the Chromatic Number\nNow that we have a string representation of the chromatic polynomial we compute the chromatic number as the least positive integer for which the represented polynomial has a positive value. As \\(\\chi(G) \\leq \\Delta(G) + 1\\) for all graphs \\(G\\), this can require the computation of most \\(\\Delta(G) + 1\\) values of the chromatic polynomial.\nTo compute a value of the chromatic polynomial from the string representation output by tutte we use the GNU Maxima computer algebra software. The at command of Maxima returns the value of its first argument polynomial string at the value of variables given in the second argument. For example, if cp is the string from the previous step then at(cp, x = 0) is the value of the polynomial represented by cp at x = 0.\nm: ${max_degree}$\ncp: ${cp}$\nchi: for i: 1 thru m + 1 do\n       if at(cp, x = i) &gt; 0 then return (i)$\nprint(chi);\nMaxima is an interactive program but can also be used non-interactively through the --batch or --batch-string options. The latter is sufficient for us, because our Maxima program is very short.\ns=\"\nm: ${max_degree}$\ncp: ${cp}$\nchi: for i: 1 thru m + 1 do\n       if at(cp, x = i) &gt; 0 then return (i)$\nprint(chi);\"\n\nmaxima --batch-string=\"$s\"\nThe default output of Maxima includes a license header and all input and output, including labels. The header can be switched off using the --very-quiet option. This option also removes the labels from input and output text. So now to scrape out the chromatic number itself we use tail to restrict our view of the output to the last line. The chromatic number is centred on this line so we remove whitespace using tr.\nmaxima --very-quiet --batch-string=\"$s\"\\\n  | tail -n 1\\\n  | tr -d ' \\t\\r\\f'"
  },
  {
    "objectID": "posts/2014-07-11-chromatic-polynomials/index.html",
    "href": "posts/2014-07-11-chromatic-polynomials/index.html",
    "title": "Chromatic Polynomials",
    "section": "",
    "text": "Until now we have considered two different simple methods for colouring vertices of graphs. Greedy colouring and recursive removal of independent subgraphs. Neither of which guarantee a colouring with the minimum number of colours under the most general conditions.\nIn the last few posts we did some simple experimentation to compare the total of chromatic numbers over all graphs on at most seven vertices against the total colours used by our greedy and recursive independent set extraction methods. This experimentation turned up some unexpected numbers and so it became necessary to investigate the data we have been using more closely so as to rule out corrupt data as a reason for the discrepancy.\nWe observed two things from these small experiments. Firstly, we observed that both methods used more colours than the minimum. We also observed that our NetworkX-based implementation of the greedy method appears to use many more colours than Joseph Culberson’s C version. For this reason we started to think about ways in which we could verify the data used.\nAs we know the distribution of chromatic numbers over small graphs, one method to verify the graph data we are using is to try to reproduce this chromatic distribution data.\nIn this post we therefore present an implementation of the chromatic number based on the chromatic polynomial. In upcoming posts we will return to the verification of experimental data collected in previous posts."
  },
  {
    "objectID": "posts/2014-07-11-chromatic-polynomials/index.html#the-chromatic-polynomial",
    "href": "posts/2014-07-11-chromatic-polynomials/index.html#the-chromatic-polynomial",
    "title": "Chromatic Polynomials",
    "section": "The Chromatic Polynomial",
    "text": "The Chromatic Polynomial\nThe chromatic polynomial \\(\\chi_{G}(\\lambda)\\) is the number of \\(\\lambda\\)-colourings of \\(G\\). The chromatic polynomial is, as the name suggests, a polynomial function. To compute values of the chromatic polynomial, which can then be used to calculate the chromatic number, we will exploit the fact that it is a special case of the Tutte polynomial \\(T_{G}(x, y)\\).\nTheorem\n\\[\\chi_{G}(\\lambda) = (-1)^{\\|V\\| - \\kappa(G)}\\lambda^{\\kappa(G)}T_{G}(1 - \\lambda, 0)\\]\nThe Tutte polynomial has been implemented by Björklund et al. (2008) in the tutte_bhkk module for NetworkX. Having an implementation of the Tutte polynomial, by the above Theorem, makes our job of implementing the chromatic polynomial a near triviality.\nIn the tutte_bhkk module there is a function tutte_poly which returns a nested list of coefficients of the Tutte polynomial. Our implementation of the chromatic polynomial will create a polynomial object rather than a coefficient list. So first we create a function that translates the tutte_bhkk coefficient list into a [sympy][sympy] polynomial. This is done by building a string representation of the Tutte polynomial of a graph and then using the ability of sympy.poly to construct a polynomial object from such a parameter string.\nimport sympy\nfrom tutte import tutte_poly\nimport networkx as nx\n\ndef tutte_polynomial(G):\n    T = tutte_poly(G)\n    s = ' + '.join(['{0}*x**{1}*y**{2}'.format(T[i][j], i, j) for i in range(len(T)) for j in range(len(T[i]))])\n    return sympy.poly(s)\nWith this function now we can find, for example, the Tutte polynomial of the Petersen graph.\nP = nx.petersen_graph()\ntutte_polynomial(P)\n\\(\\operatorname{Poly}{\\left( x^{9} + 6 x^{8} + 21 x^{7} + 56 x^{6} + 12 x^{5} y + 114 x^{5} + 70 x^{4} y + 170 x^{4} + 30 x^{3} y^{2} + 170 x^{3} y + 180 x^{3} + 15 x^{2} y^{3} + 105 x^{2} y^{2} + 240 x^{2} y + 120 x^{2} + 10 x y^{4} + 65 x y^{3} + 171 x y^{2} + 168 x y + 36 x + y^{6} + 9 y^{5} + 35 y^{4} + 75 y^{3} + 84 y^{2} + 36 y, x, y, domain=\\mathbb{Z} \\right)}\\)\nWith the Tutte polynomial implemented as a sympy polynomial constructing the chromatic polynomial of a graph is a no more than a simple expression. For greater convenience we embody this expression in a function, chromatic_polynomial.\nfrom sympy.abc import x,y,l\n\ndef chromatic_polynomial(G):\n    k = nx.number_connected_components(G)\n    tp = tutte_polynomial(G).subs({x: 1 - l, y: 0})\n    return sympy.expand((-1)**(G.number_of_nodes() - k)*l**k*tp)\nReturning to the Petersen graph, the chromatic polynomial is:\ncp = chromatic_polynomial(P)\ncp\n\\(- l \\operatorname{Poly}{\\left( - l^{9} + 15 l^{8} - 105 l^{7} + 455 l^{6} - 1353 l^{5} + 2861 l^{4} - 4275 l^{3} + 4305 l^{2} - 2606 l + 704, l, domain=\\mathbb{Z} \\right)}\\)\nNow to use the chromatic polynomial to find the chromatic number of a graph it should be clear what we have to do. The Poly member function subs allows us to compute values of the chromatic polynomial. As there are no 2-colourings of the Petersen graph we expect that cp.subs(l, 2) is zero, which it is.\ncp.subs(l, 2)\n0\nThen if we compute cp.subs(l, 3) we are not surprised to see a non-zero value because we already knew that the chromatic number of the Petersen graph is 3.\ncp.subs(l, 3)\n120\nWe see that the chromatic number of the Petersen graph is 3 because that is the least integral value of \\(\\lambda\\) for which \\(\\chi(G, \\lambda) &gt; 0\\), when \\(G\\) is the Petersen graph.\nThe same calculations for the Chvatal graph show that the chromatic number of the Chvatal graph is 4:\nC = nx.chvatal_graph()\ncp2 = chromatic_polynomial(C)\n\ncp2.subs(l, 3)\n0\ncp2.subs(l, 4)\n18024\nApart from some simple cases with graphs with no edge or vertices the chromatic number is found by as the least \\(\\lambda \\in \\{1, \\ldots, \\Delta(G) + 1\\}\\) for which \\(\\chi(G, \\lambda) &gt; 0\\).\ndef chromatic_number(G):\n    if G.number_of_nodes() == 0:\n        return 0\n    elif G.number_of_edges() == 0:\n        return 1\n    elif G.number_of_edges() == 1:\n        return 2\n    else:\n        p = chromatic_polynomial(G)\n        for i in range(max(G.degree().values()) + 2):\n            if p.subs(l, i) &gt; 0:\n                return i"
  },
  {
    "objectID": "posts/2014-07-11-chromatic-polynomials/index.html#chromatic-numbers-of-small-graphs",
    "href": "posts/2014-07-11-chromatic-polynomials/index.html#chromatic-numbers-of-small-graphs",
    "title": "Chromatic Polynomials",
    "section": "Chromatic Numbers of Small Graphs",
    "text": "Chromatic Numbers of Small Graphs\nIn this section we return again to the set of all graphs on at most seven vertices, albeit with more care than was given in previous posts. The first objective is to reproduce Gordon Royle’s table of chromatic numbers of small graphs as far as graphs on seven vertices. In doing this we recognise one reason for previously reported discrepant data. Royle’s table is a table of chromatic numbers for connected graphs whereas our approximations to the sum of all chromatic numbers were computed over the set of all graphs of order at most seven.\nBelow, we construct two lists data and c_data. The data list is populated with the chromatic number data for all graphs in the set graph_atlas_g() of all graphs on at most seven vertices. The c_data list records the same data but only for connected graphs.\nfrom networkx.generators.atlas import graph_atlas_g\nG = graph_atlas_g()\n\ndata = [8*[0] for i in range(8)]\nc_data = [8*[0] for i in range(8)]\n\nfor g in G:\n    n = g.number_of_nodes()\n    c = chromatic_number(g)\n    data[c][n] += 1\n    if nx.number_connected_components(g) == 1:\n        c_data[c][n] += 1\nCreating a table of the distribution of chromatic numbers over all connected graphs of order at most seven we reproduce Royle’s data. The function html_table (not shown here) is based on Caleb Madrigal’s post Display List as Table in IPython Notebook.\nfrom IPython.display import HTML\n\nT = [['$\\chi$','$n = 3$','$n = 4$','$n = 5$','$n = 6$','$n = 7$']]\n\nrows = c_data[2:]\n\nfor i in range(len(rows)):\n    R = [i + 2]\n    for cell in rows[i][3:]:\n      R.append(cell)\n    T.append(R)\n\nHTML(html_table(T))\n\n\n\n\\(\\chi\\)\n\n\n\\(n = 3\\)\n\n\n\\(n = 4\\)\n\n\n\\(n = 5\\)\n\n\n\\(n = 6\\)\n\n\n\\(n = 7\\)\n\n\n\n\n2\n\n\n1\n\n\n3\n\n\n5\n\n\n17\n\n\n44\n\n\n\n\n3\n\n\n1\n\n\n2\n\n\n12\n\n\n64\n\n\n475\n\n\n\n\n4\n\n\n0\n\n\n1\n\n\n3\n\n\n26\n\n\n282\n\n\n\n\n5\n\n\n0\n\n\n0\n\n\n1\n\n\n4\n\n\n46\n\n\n\n\n6\n\n\n0\n\n\n0\n\n\n0\n\n\n1\n\n\n5\n\n\n\n\n7\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n1\n\n\n\nThe same data over all graphs of order at most seven is given in the following table.\nrows = data[2:]\n\nT = [['$\\chi$','$n = 3$','$n = 4$','$n = 5$','$n = 6$','$n = 7$']]\n\nfor i in range(len(rows)):\n    R = [i + 2]\n    for cell in rows[i][3:]:\n      R.append(cell)\n    T.append(R)\n\nHTML(html_table(T))\n\n\n\n\\(\\chi\\)\n\n\n\\(n = 3\\)\n\n\n\\(n = 4\\)\n\n\n\\(n = 5\\)\n\n\n\\(n = 6\\)\n\n\n\\(n = 7\\)\n\n\n\n\n2\n\n\n2\n\n\n6\n\n\n12\n\n\n34\n\n\n87\n\n\n\n\n3\n\n\n1\n\n\n3\n\n\n16\n\n\n84\n\n\n579\n\n\n\n\n4\n\n\n0\n\n\n1\n\n\n4\n\n\n31\n\n\n318\n\n\n\n\n5\n\n\n0\n\n\n0\n\n\n1\n\n\n5\n\n\n52\n\n\n\n\n6\n\n\n0\n\n\n0\n\n\n0\n\n\n1\n\n\n6\n\n\n\n\n7\n\n\n0\n\n\n0\n\n\n0\n\n\n0\n\n\n1\n\n\n\nSo this gives us some confidence in the NetworkX data as well as the above method for computing chromatic numbers."
  },
  {
    "objectID": "posts/2014-05-30-drawing-coloured-queen-graphs/index.html",
    "href": "posts/2014-05-30-drawing-coloured-queen-graphs/index.html",
    "title": "Drawing Coloured Queen Graphs",
    "section": "",
    "text": "Continuing from last week’s post, in this post we will demonstrate how to use the osage program from Graphviz, to create rectangular drawings of coloured queen graphs. The drawings produced, like the one below, resemble coloured chess boards. Edges in these drawings are invisible but, as we will explain, it is still easy to decide whether or not the colouring of the graph is proper.\nBeginning with a queen graph in DIMACS format from Michael Trick’s graph colouring instances page the goal is to produce a properly coloured queen graph in DOT format. For smaller queen graphs we can achieve colourings that use the minimal number of colours using the smallk program of Joseph Culberson. With the resulting colouring data the original DIMACS format graph data both converted into DOT format it is then a simple matter to invoke osage to produce drawings like the one above.\nWith the intention that others should be able to reproduce our drawings we have made available the source code in the form of several scripts and a Makefile.\nThe rest of this post has the following structure:\nIn an upcoming post we will return to the question of verifying, automatically, the properness of colourings."
  },
  {
    "objectID": "posts/2014-05-30-drawing-coloured-queen-graphs/index.html#colouring-queen-graphs-with-small-chromatic-number",
    "href": "posts/2014-05-30-drawing-coloured-queen-graphs/index.html#colouring-queen-graphs-with-small-chromatic-number",
    "title": "Drawing Coloured Queen Graphs",
    "section": "Colouring Queen Graphs with Small Chromatic Number",
    "text": "Colouring Queen Graphs with Small Chromatic Number\nIn this post we consider several smaller queen graphs. Namely the \\(5 \\times 5\\), \\(6 \\times 6\\) and \\(7 \\times 7\\) queen graphs. These have, respectively, chromatic number 5,6 and 7.\nOne of Culberson’s graph colouring programs, smallk, is capable of properly colouring graphs with chromatic number at most 8. Consider, for example, the \\(5 \\times 5\\) queen graph. Using smallk to generate a colouring of this graph with 5 colours goes like so:\n$ smallk queen5_5.col 1 5\nThe first argument is a randomisation seed and the second argument is the number of colours to use. If the program is successful in finding a colouring, then the output, as with all of Culberson’s colouring programs is a file that looks something like this:\nCLRS 5 FROM SMALLK cpu =  0.00 pid = 23501\n  2   1   5   4   3   5   4   3   2   1   3   2   1   5   4   1   5   4   3   2 \n  4   3   2   1   5 \nThe DOT format supports vertex colouring through vertex attributes. So a conversion of this output into DOT format might begin something like this:\n1 [color=red];\n2 [color=blue];\n3 [color=green];\nAssuming a mapping of integers to colours \\(1\\mapsto\\text{blue}\\), \\(2\\mapsto\\text{red}\\), \\(5\\mapsto\\text{green}\\) …\nIn the next section we demonstrate how to take this data, along with the original graph data and produce a file representing the same graph in DOT format with the vertices coloured according to a mapping of integers to colours."
  },
  {
    "objectID": "posts/2014-05-30-drawing-coloured-queen-graphs/index.html#drawing-coloured-chess-boards",
    "href": "posts/2014-05-30-drawing-coloured-queen-graphs/index.html#drawing-coloured-chess-boards",
    "title": "Drawing Coloured Queen Graphs",
    "section": "Drawing Coloured Chess Boards",
    "text": "Drawing Coloured Chess Boards\nThe drawing of our coloured queen graph will be done by osage which, like all programs belonging to the Graphviz project requires graph data to be in DOT format. In this section we show how to convert graphs from DIMACS to DOT format and then how to augment DOT format files with vertex colourings produced by smallk.\nThe method of this section has been implemented as Makefile which depends on several scripts introduced in the following paragraphs.\nThe first script dimacs2gv converts graphs from DIMACS format to DOT format. This script is little more than a sed one-liner and doubtless is neither particularly flexible nor especially robust, but suffices, at least, for our purposes and, probably, can be used in a more general setting.\nWhen passed a graph file in DIMACS format, the output of dimacs2gv is the same graph in DOT format.\n$ dimacs2gv queen5_5.col &gt; queen5_5.gv\nA second script colour takes the output of smallk and generates DOT format vertex colouring data.\n$ colour queen5_5.col.res &gt; tmp.txt\nThe output of colour should be added to the DOT output from dimacs2gv to produce a single file in DOT format which has all of the information, adjacency and vertex colour. The two files can be combined via sed:\n$ sed -i '1r tmp.txt' queen5_5.gv\nThis command just says insert the contents of file tmp.txt at line 1 of the file queen5_5.gv. The -i option to sed means make the changes in-place, modifying the file directly instead of printing the result.\nThe DOT file now can be drawn using the osage program. There are several options to configure. The most significant of which are those that set the style of edge to invisible (-Estyle=invis) and those which make the vertices by drawn as unlabelled boxes (-Nshape=box and -Nlabel=). The other options mostly concern sizes of objects and format of output and output filename.\n$ osage -s -Tsvg \n        -Gsize=5,5\\! \n        -Nshape=box -Nwidth=1 -Nheight=1 -Nfixedsize=true -Nlabel=\n        -Estyle=invis\n         queen5_5.gv -o queen5_5.svg\nThe output of this command is an image in SVG format that looks something like the drawing at the beginning of this post.\nHere are drawings of minimal colourings of the \\(6 \\times 6\\):\n\n\n\nGreedy colouring of 6x6 Queen graph\n\n\nand \\(7 \\times 7\\) queen graphs:\n\n\n\nGreedy colouring of 7x7 Queen graph\n\n\nTo check these drawings for properness is easy, even though the edges are not drawn. Choose a colour and allow your eye to pick up all squares of that colour. None lie in the same row, column or diagonal. So no pair of that colour can be occupied by queens who can take each other. Doing this manually for six or seven colours only takes a few seconds. Of course, we would like to have a little program to do this automatically for us and that is a topic we will return to in a subsequent post."
  },
  {
    "objectID": "posts/2014-05-09-lombardi-drawings/index.html",
    "href": "posts/2014-05-09-lombardi-drawings/index.html",
    "title": "Lombardi Drawings",
    "section": "",
    "text": "Mark Lombardi (1951–2000) was an American artist whose network diagrams, like the one below, reveal close connections between actors in the domains of international politics and finance.\nIn this post we examine recent work to emulate the aesthetic qualities of Lombardi’s drawings in the realm of graph drawing. More information about Mark Lombardi can be found in the papers Zdebik (2011) and Friedman (2011) and in this story from a 2003 episode of Morning Edition on NPR.\nLombardi’s diagrams have very strong aesthetic qualities. These qualities have been attributed, in part, to his use of circular arcs for edges as well as his efforts to achieve equal spacing of edges around node perimeters; so-called perfect angular resolution.\nIn Duncan et al. (2010) the notion of a Lombardi drawing of a graph is introduced. Such a drawing has perfect angular resolution as well as circular arc edges. The authors describe several methods for finding Lombardi drawings of graphs and they introduce a Python program called the Lombardi Spirograph which can produce Lombardi drawings of graphs.\nIn this post we will demonstrate how to use the Lombardi Spirograph to draw certain named graphs, how to use options to customise drawings and we will give two examples of the special input language for drawing graphs other than named ones."
  },
  {
    "objectID": "posts/2014-05-09-lombardi-drawings/index.html#drawing-named-graphs",
    "href": "posts/2014-05-09-lombardi-drawings/index.html#drawing-named-graphs",
    "title": "Lombardi Drawings",
    "section": "Drawing Named Graphs",
    "text": "Drawing Named Graphs\nThe basic usage pattern for the Lombardi Spirograph is:\n$ python LombardiSpirograph.py [options] graph_name &gt; output.svg\nwhere graph_name is to be replaced by either one of the names of the known named graphs or by a description of a graph using the specialist input language.\nFor example, to draw the Grötzsch graph with the default options:\n$ python LombardiSpirograph.py grotzsch &gt; grotzsch.svg\nWhich results in the following drawing:\n\n\n\nLombardi Spirograph drawing of Groetzsch graph"
  },
  {
    "objectID": "posts/2014-05-09-lombardi-drawings/index.html#options",
    "href": "posts/2014-05-09-lombardi-drawings/index.html#options",
    "title": "Lombardi Drawings",
    "section": "Options",
    "text": "Options\nThe Lombardi Spirograph allows customisation of several aspects of the produced drawing. We can scale the drawing and choose different styling options for the vertices: the colour, size and whether vertices have visible outlines or not. For example, to draw the Grötzsch graph again, slightly larger with smaller blue nodes not having visible outlines:\n$ python LombardiSpirograph.py \\\n    --scale=1.2 \\\n    --color=blue \\\n    --radius=0.8 \\\n    --outline \\\n    grotzsch &gt; grotzsch_alt.svg\n\n\n\nLombardi Spirograph drawing of Groetzsch graph"
  },
  {
    "objectID": "posts/2014-05-09-lombardi-drawings/index.html#drawing-other-graphs",
    "href": "posts/2014-05-09-lombardi-drawings/index.html#drawing-other-graphs",
    "title": "Lombardi Drawings",
    "section": "Drawing Other Graphs",
    "text": "Drawing Other Graphs\nThe input language for drawing other graphs is described by the authors in the Lombardi Spirograph online documentation. The description can be read by running the program with the --format flag.\n$ python LombardiSpirograph.py --format\n\nThe graph should be described as a sequence of alphanumeric words, separated either by spaces or by blank lines. The first word gives the order of symmetry of the drawing (the number of vertices in each concentric layer) and each subsequent word describes the vertices in a single layer of the graph.\n\n\nEach word after the first takes the form of a (possibly empty) sequence of letters followed by a (possibly empty) number. The letters describe edges connecting two vertices in the same layer: “a” for a connection between consecutive vertices in the same layer, “b” for a connection between vertices two steps away from each other, etc. The letters should be listed in the order the connections should appear at the vertex, starting from the edge closest to the center of the drawing and progressing outwards. Only connections that span less than half the circle are possible, except that the first layer may have connections spanning exactly half the circle.\n\n\nThe numeric part of a word describes the connection from one layer to the next layer. If this number is zero, then vertices in the inner layer are connected to vertices in the next layer radially by straight line segments. Otherwise, pairs of vertices from the inner layer, the given number of steps apart, are connected to single vertices in the outer layer. A nonzero number written with a leading zero (e.g. “01” in place of “1”) indicates that, as well as connections with the given number of steps, there should also be a radial connection from the inner layer to the next layer that has vertices aligned with it; this may not necessarily be the layer immediately outward.\n\n\nIn the innermost layer, the special word “x” may be used to indicate that the layer consists of a single vertex at the center of the drawing. “x0” indicates that this central vertex is connected both to every vertex in the adjacent layer and also to every vertex in the next layer that is staggered with respect to the inner two layers.\n\nBelow are two examples. The icosahedron, which is one of the named graphs, and the Petersen graph, which is also named but in a different way than in the example below.\nExample 1 – Icosahedron\nA possible code for a Lombardi drawing of the icosahedron is 3-a01-01-1-a. The drawing that results is:\n\n\n\nLombardi Spirograph drawing of Icosahedron graph\n\n\nHere is how to interpret the graph description and see how the above drawing is produced from it.\n\n3 - Gives the order of symmetry (vertices in each layer);\na01 - describes connections with vertices in first (innermost) layer;\n\na - consecutive vertices in this layer are joined by an edge;\n01 - pairs of vertices one step apart in this layer are joined to vertices in the next layer and there are radial lines to the next aligned layer (in this case the third);\n\n01 - pairs of vertices in second layer which are one step apart in this layer are joined to vertices in the next layer and there are radial lines to the next aligned layer (the fourth);\n1 - pairs of vertices in second layer which are one step apart in this layer are joined to vertices in the next layer;\na - consecutive vertices in fourth (outermost) layer are joined by an edge.\n\nExample 2 – The Petersen Graph\nAccording to the above description we can deduce that 5-b0-a is a representation of a drawing of the Petersen graph. The drawing produced by the Lombardi Spirograph is shown below.\n\n\n\nLombardi Spirograph drawing of Petersen graph"
  },
  {
    "objectID": "posts/2014-06-13-greedy-vertex-colouring/index.html",
    "href": "posts/2014-06-13-greedy-vertex-colouring/index.html",
    "title": "Greedy Vertex Colouring",
    "section": "",
    "text": "In this post we demonstrate some of the basic ideas of vertex colouring. In particular, we demonstrate the following result.\nTheorem 1\nFor every graph \\(G\\), \\[\\chi(G) \\leq 1 + \\Delta(G)\\]\nOne proof of this result is found on p.182 of Chartrand and Zhang (2008) where it appears as Theorem 7.8. The proof is no more than a precise version of the observation that if we apply a greedy vertex colouring then we only need at most \\(\\Delta(G) + 1\\) colours because if we have that many colours then when it comes time to colour a certain vertex one is bound to be missing from the at most \\(\\Delta(G)\\) neighbours of that vertex."
  },
  {
    "objectID": "posts/2014-06-13-greedy-vertex-colouring/index.html#greedy-vertex-colouring",
    "href": "posts/2014-06-13-greedy-vertex-colouring/index.html#greedy-vertex-colouring",
    "title": "Greedy Vertex Colouring",
    "section": "Greedy Vertex Colouring",
    "text": "Greedy Vertex Colouring\nThe greedy vertex colouring algorithm starts with the vertices of a graph listed in some order \\(v_{1},v_{2},...v_{n}\\). It begins with the first vertex and assigns that vertex colour 1. To colour a vertex \\(v_{j + 1}\\) further along in the sequence we choose the first colour which is not used on any of the already coloured vertices \\(\\{v_{1},...v_{j}\\}\\).\nBelow is an implementation of the greedy vertex colouring algorithm for NetworkX graphs. In fact, this implementation is a little more flexible than the one described in the previous paragraph. It allows for some customisation of the algorithm’s behaviour. Specifically, it allows use to specify both the ordering of the nodes and the strategy used to select which colour to use one a particular node.\nHere we have only implemented one strategy, the first_available strategy of the greedy algorithm which chooses the first colour not used on already coloured neighbours.\ndef first_available(G, node, palette):\n    \"\"\"Returns the first colour in palette which is not used in G on any\n    neighbours of node, where D is the maximum degree.\"\"\"\n    used_on_neighbours = []\n    for v in G[node]:\n        used_on_neighbours.append(G.node[v].get('colour'))\n    available_colour_set = set(palette) - set(used_on_neighbours)\n    return sorted(available_colour_set)[0]\n\ndef vcolour(G, choose_colour = first_available, nodes = None):\n    \"\"\"Visits every vertex in G and assigns a colour from [0..D] given by\n    the choose_colour function object, where D is the maximum degree\"\"\"\n    if nodes == None:\n        nodes = G.nodes()\n    degseq = G.degree().values()\n    if degseq!=[]:\n        palette = range(max(degseq) + 1)\n    else:\n        palette = range(1)\n    for node in nodes:\n        G.node[node]['colour'] = choose_colour(G, node, palette)\nNotice that this implementation colours graphs in-place. It adds a colour attribute to every vertex and the value of this attribute is the colour given to that vertex.\nBelow is an example of using the greedy colouring algorithm to colour \\(K_{9}\\). By the earlier theorem we would expect a colouring with 9 colours, as \\(\\Delta(K_{9}) = 8\\).\nimport networkx as nx\nsetfigsize(5, 5)\n\noptions = {\n 'with_labels': False,\n 'node_size': 300,\n 'width': 1,\n}\n\ndef colours(G):\n    \"\"\"Returns a list of colours used on vertices in G.\"\"\"\n    return [x.get('colour') for x in G.node.values()]\n\nK9 = nx.complete_graph(9)\nvcolour(K9)\nnx.draw_circular(K9, node_color = colours(K9), **options)\n\n\n\npng\n\n\nThe colours function gets a list of colours used on vertices which is then passed to the draw_circular function as the argument of a keyword parameter node_colour.\nWe put other options into a dictionary object so that we can reuse the same options in other drawings below.\nColouring a complete graph doesn’t pose much of a challenge to any colouring algorithm. All that is needed to assign a different colour to each vertex so algorithms even simpler than the greedy algorithm will succeed in this case to find a minimal colouring.\nA slightly more challenging graph is a complete bipartite graph. If we consider \\(K_{5,6}\\), for example, the above Theorem only guarantees a colouring with 7 colours. A minimal colouring, however, uses only 2 colours.\nK56 = nx.complete_bipartite_graph(5,6)\nvcolour(K56)\nnx.draw_circular(K56, node_color = colours(K56), **options)\n\n\n\npng\n\n\nIt isn’t really all that surprising that we found a minimal colouring here. If we have managed to colour some of the vertices properly with only two colours in such a way that all vertices of one colour lie in one of the bipartitions and all the vertices of the other colour lie in the other bipartition then it’s obvious how to extend this to a similar 2-colouring with fewer uncoloured vertices."
  },
  {
    "objectID": "posts/2014-06-13-greedy-vertex-colouring/index.html#colouring-some-classic-graphs",
    "href": "posts/2014-06-13-greedy-vertex-colouring/index.html#colouring-some-classic-graphs",
    "title": "Greedy Vertex Colouring",
    "section": "Colouring Some Classic Graphs",
    "text": "Colouring Some Classic Graphs\nIn this section we apply the greedy colouring algorithm from the previous section to some well-known graphs and compare the number of colours used with the chromatic number.\nFirst we consider the Petersen graph. It is known to have chromatic number 3 and, indeed, with our greedy colouring algorithm we find a 3-colouring.\nP = nx.petersen_graph()\nvcolour(P)\nnx.draw_shell(P, nlist=[range(5,10), range(5)], node_color = colours(P), **options)\n\n\n\npng\n\n\nThe dodecahedral graph is a slightly different story. It also has chromatic number 3 but with the greedy algorithm we find a colouring with four colours.\nsetfigsize(6, 6)\n\nG = nx.dodecahedral_graph()\nvcolour(G)\nnlist = [[2,3,4,5,6],[8,1,0,19,18,17,16,15,14,7],[9,10,11,12,13]]\nnx.draw_shell(G, nlist = nlist , node_color = colours(G), **options)\n\n\n\npng\n\n\nA 4-colouring of a 3-regular graph is still in accordance with Theorem 1. We might, though, do better by experimenting a little with node orderings or colour choice strategies. The first thing worth trying would be a few random orderings, hoping to hit upon one that uses only 3 colours.\nrandom.seed(1)\n\nG = nx.dodecahedral_graph()\nnodes = G.nodes()\nrandom.shuffle(nodes)\nvcolour(G, nodes = nodes)\nnlist = [[2,3,4,5,6],[8,1,0,19,18,17,16,15,14,7],[9,10,11,12,13]]\nnx.draw_shell(G, nlist = nlist , node_color = colours(G), **options)\n\n\n\npng\n\n\nAs luck would have it, we have hit upon a 3-colouring straight away, without much effort."
  },
  {
    "objectID": "posts/2014-08-08-colouring-small-graphs-update/index.html",
    "href": "posts/2014-08-08-colouring-small-graphs-update/index.html",
    "title": "Colouring Small Graphs: Update",
    "section": "",
    "text": "In Colouring Small Graphs we attempted to reproduce Gordon Royle’s data on the distribution of chromatic numbers of small graphs. We were partially successful, reproducing his results for graphs of order at most seven using the chromatic shell script built on the implementation of the Tutte polynomial by Haggard, Pearce, and Royle (2010) .\nOur simulation, however, ran into difficulty with graphs of order eight. We found a distribution of chromatic numbers different from Royle’s. As we had been successful with smaller orders it seemed most likely that we had some issue with corrupt data. The small graph data we started with comes from a reliable source and therefore the corruption was probably introduced by our ad-hoc methods of translating formats.\nOur format conversion had two steps. We started with McKay’s graph6 format data, first converting this into Dimacs format. Then we took the Dimacs format data and converted it into Graphviz DOT format. The reason behind the two step approach was that we had previously implemented Dimacs to DOT conversion in Sed. Since then, however, we have discovered that McKay’s gtools collection of programs from the nauty McKay and Piperno (2014) project already implements conversion to DOT format.\nThe second conversion step involved splitting one file containing one graph per line into a folder of files with one graph per file. We had written an AWK program to do this but have since discovered the csplit program in the GNU Coreutils package which is specifically for this purpose.\nUsing these more appropriate tools has solved the problem with our reproduction of Royle’s colouring data and in this post we reproduce his table of chromatic numbers of connected graphs as far as graphs of order eight."
  },
  {
    "objectID": "posts/2014-08-08-colouring-small-graphs-update/index.html#overview",
    "href": "posts/2014-08-08-colouring-small-graphs-update/index.html#overview",
    "title": "Colouring Small Graphs: Update",
    "section": "Overview",
    "text": "Overview\nWe start with Brendan McKay’s small graph data files in graph6 format with one graph per line and one file per order. We consider only connected graphs.\nThe simulation itself aims to reproduce the table of chromatic numbers of small graphs of Gordon Royle.\nTo reproduce the desired output we follow three steps:\n\nConvert graph6 data into DOT data.\nProcess DOT data. Compute the chromatic number of every graph and store chromatic numbers in per-order results files.\nCollate the per-order distributions into a table.\n\nIn previous posts we have tried, as far as possible, to emphasise the Unix pipeline approach to presenting a workflow. An advantage of this approach is a pipeline can be cut from the blog and pasted into a console to reproduce our simulation. A secondary benefit is that it encourages us to adhere to Unix philosophies like having small, orthogonal programs that can be combined together into pipelines to achieve more complicated tasks. We have also used Make as a more powerful language for expressing computational workflows. In this post we are going to use a Make-like tool Drake which is designed specifically for the task of expressing and automating a computational workflow. Drake is not part of GNU but it is free software.\nIn the rest of this post we describe each of the three steps above in more detail. At the end of this post is a Drakefile which can be used to reproduce the second two steps of our simulation. At the point of writing the data conversion step is embedded in a Makefile inside the graphs-collection project."
  },
  {
    "objectID": "posts/2014-08-08-colouring-small-graphs-update/index.html#convert-graph-data",
    "href": "posts/2014-08-08-colouring-small-graphs-update/index.html#convert-graph-data",
    "title": "Colouring Small Graphs: Update",
    "section": "Convert Graph Data",
    "text": "Convert Graph Data\nThis is much easier than before. The listg program in the gtools collection of programs can output graphs in DOT format by using the -y switch.\n$ curl -s http://cs.anu.edu.au/~bdm/data/graph4c.g6 | listg -y\ngraph G1 {\n0--3;\n1--3;\n2--3;\n}\ngraph G2 {\n0--2;\n0--3;\n1--3;\n}\ngraph G3 {\n0--2;\n0--3;\n1--3;\n2--3;\n}\ngraph G4 {\n0--2;\n0--3;\n1--2;\n1--3;\n}\ngraph G5 {\n0--2;\n0--3;\n1--2;\n1--3;\n2--3;\n}\ngraph G6 {\n0--1;\n0--2;\n0--3;\n1--2;\n1--3;\n2--3;\n}\nNow we split this output across several files using csplit.\ncurl http://cs.anu.edu.au/~bdm/data/graph4c.g6\n| listg -y\n| csplit -sz -b '%d.gv' -f '' - '/^graph.*/' '{*}'\nThe result of this pipeline are six files 0.gv through 5.gv containing the six graphs above.\nOptions for csplit are explained in the csplit manpage and in more detail in the [csplit documentation](http://www.gnu.org/software/coreutils/manual/html_node/csplit-invocation.html. The relevant options in this case are\n\n-s – Quiet output. Otherwise csplit prints out the size of each output file.\n-z – Remove empty output files.\n-b – This option has an argument describing the suffix format.\n-f – Prefix format. We have chosen an empty prefix. The default is xx.\n\nThe hyphen in the option list represents standard input. After that comes two patterns. The first is used to decide where to split. In this case we begin on any line that begins with the string graph. The second '{*}' pattern tells csplit to repeat the splitting as many times as possible."
  },
  {
    "objectID": "posts/2014-08-08-colouring-small-graphs-update/index.html#process-graph-data",
    "href": "posts/2014-08-08-colouring-small-graphs-update/index.html#process-graph-data",
    "title": "Colouring Small Graphs: Update",
    "section": "Process Graph Data",
    "text": "Process Graph Data\nAt this point we have a collection of files in DOT format representing all connected graphs of a certain order. For each graph we compute the chromatic number, using the chromatic script, and append the result to a file of chromatic numbers of all graphs of the same order.\nIn this section we describe the workflow using Drake, a Make-like program designed for describing and automating computational workflows.\nDrake is used by writing a Drakefile. A Drakefile bears the same relation to Drake that a Makefile bears to Make. It contains a list of rules which describe how to make an output file from an input file, collection of input files or folder.\nFor example, if 4c_gv is a folder containing all connected graphs of order four then a Drake rule which generates a file 4c_chromatic.txt containing the chromatic numbers of all graphs in the folder looks like this.\n4c_chromatic.txt &lt;- 4c_gv\n  for graph in $INPUTS/*;\n  do\n   chromatic ${graph} &gt;&gt; $OUTPUT\n  done\nThe assignment of 4c.gv to the variable INPUTS and 4c_chromatic.txt to the variable OUTPUT is done automatically by Drake.\nThe body of this rule is something that can be used in the rules for graphs of other orders. So we create a method, compute_chromatic, and assign the method to rules using the [method: compute_chromatic] rule option.\ncompute_chromatic()\n  for graph in $INPUTS/*;\n  do\n   chromatic ${graph} &gt;&gt; $OUTPUT\n  done\n\n4c_chromatic.txt &lt;- 4c_gv [method:compute_chromatic]"
  },
  {
    "objectID": "posts/2014-08-08-colouring-small-graphs-update/index.html#analyse-results",
    "href": "posts/2014-08-08-colouring-small-graphs-update/index.html#analyse-results",
    "title": "Colouring Small Graphs: Update",
    "section": "Analyse Results",
    "text": "Analyse Results\nThe first stage of analysis is to take all the generated files of chromatic numbers and create new files containing the distribution of chromatic numbers. These files will contain two tab-separated columns. The first column being a list of possible chromatic numbers and the second being a count of graphs having that chromatic number.\nFor this purpose a Drake method make_distribution runs through a sequence of possible chromatic numbers. For each value grep counts the occurrences in the input file of that value and appends the result to an output file. The GNU Coreutils cut and paste are used, along with the arbitrary precision calculator language bc, to compute a total count for each chromatic number which is appended to the end of the output file.\nmake_distribution()\n  for j in `seq 1 8`\n  do\n   echo -e $j'\\t' `grep -c $j $INPUT` &gt;&gt; $OUTPUT\n  done\n  echo -e Total:'\\t' `cut -f 2 $OUTPUT | paste -sd+ | bc` &gt;&gt; $OUTPUT\n\n4c_distribution.txt &lt;- 4c_chromatic.txt [method:make_distribution]\nThe second task is to take all of the distribution files (one for each order) and build a table to match the Royle table. To do this a Drake rule takes the distribution files as input and produces, as output, a file table.txt containing the table. The work is done by GNU Coreutils paste and cut which are piped together to join all distribution files into a single file and then select the relevant columns to produce the final table.\ntable.txt &lt;- 2c_distribution.txt,\n             3c_distribution.txt,\n             4c_distribution.txt,\n             5c_distribution.txt,\n             6c_distribution.txt,\n             7c_distribution.txt,\n             8c_distribution.txt\n  paste $INPUTS | cut -f 1,2,4,6,8,10,12,14 &gt; $OUTPUT\nThe output of this rule is a file table.txt which contains the following table.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\[n = 2\\]\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\\[\\chi =  2\\]\n0\n1\n3\n5\n10\n15\n26\n37\n\n\n3\n0\n1\n5\n14\n46\n123\n350\n772\n\n\n4\n0\n0\n0\n10\n55\n258\n749\n1476\n\n\n5\n0\n0\n0\n2\n23\n104\n305\n568\n\n\n6\n0\n0\n0\n0\n0\n18\n57\n125\n\n\n7\n0\n0\n0\n0\n0\n0\n9\n22\n\n\n8\n0\n0\n0\n0\n0\n0\n0\n4\n\n\n9\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nTotal:\n0\n2\n8\n31\n134\n518\n1496\n3004\n\n\n\nThis table agrees with Royle’s as far as it goes. As yet we haven’t been able to extend our results to higher order because our brute-force-ish approach is too slow to process all 261080 connected graphs of order 9 in a reasonable amount of time. The good news, though, is that we have left plenty of room for improvement to the speed of our code and our approach should be ripe for parallelisation. So there is a good chance that in the future we can extend our table to match Royle’s at least as far as order 9."
  },
  {
    "objectID": "posts/2014-09-26-greedy-edge-colouring-of-small-graphs/index.html",
    "href": "posts/2014-09-26-greedy-edge-colouring-of-small-graphs/index.html",
    "title": "Greedy Edge Colouring of Small Graphs",
    "section": "",
    "text": "In seveal earlier posts we looked at greedy vertex-colouring of small graphs. As we saw, a greedy approach to vertex-colouring is quite successful in so far as it uses at most \\(\\Delta(G) + 1\\) colours to colour any graph \\(G\\).\nIt is easy to modify the greedy method to colour the edges of a graph. However, we cannot guarantee that the number of colours used will be as few as \\(\\Delta(G) + 1\\). The best that we can guarantee with the simplest greedy approach to edge-colouring is no more than \\(2\\Delta(G) - 1\\) colours.\nIt’s not difficult to see why this is, for suppose that we have coloured some edges of the graph and come to colour edge \\(e = uv\\). There might be as many as \\(\\Delta(G) - 1\\) colours on edges incident with \\(u\\) and the same amount on edges incident with \\(v\\). In the worst case, all of these \\(2\\Delta(G) - 2\\) colours might be different and so we need at least \\(2\\Delta(G) - 1\\) colours in our palette to be certain, without recolouring, to have a colour available for edge \\(e\\).\nIn this post we introduce a NetworkX-based implementation of greedy edge-colouring for graphs in graph6 format. Using this implementation we investigate the average case performance on all non-isomorphic, connected simple graphs of at most nine vertices. It turns out that, on average, the greedy edge-colouring method uses many fewer colours than the worst case of \\(2\\Delta(G) - 1\\).\nAs we will discuss, the theory of edge-colouring suggests that with large sets of simple graphs we can get close, on average, to the best case of \\(\\Delta(G)\\) colours."
  },
  {
    "objectID": "posts/2014-09-26-greedy-edge-colouring-of-small-graphs/index.html#greedy-edge-colouring-with-networkx",
    "href": "posts/2014-09-26-greedy-edge-colouring-of-small-graphs/index.html#greedy-edge-colouring-with-networkx",
    "title": "Greedy Edge Colouring of Small Graphs",
    "section": "Greedy Edge-Colouring with NetworkX",
    "text": "Greedy Edge-Colouring with NetworkX\nThe core of our implementation is a function that visits every edge of a graph and assigns a colour to each edge according to a parametrised colour choice strategy.\ndef edge_colouring(G, choice = choice_greedy):\n    max_degree = max(G.degree().values())\n    palette = range(0, 2*max_degree)\n    for e in G.edges():\n        colour_edge(G, e, choice(G, e, palette))\nThis function allows for some flexibility in the method used to choose the colour assigned to a certain edge. Of course, it lacks flexibility in certain other respects. For example, both the order in which edges are visited and the palette of colours are fixed.\nEverything in the implementation is either Python or NetworkX, except for the colour_edge(G, e, c) and choice(G, e, p) functions. The former simply applies colour c to edge e in graph G. The latter, a function parameter that can be specified to implement different colouring strategies, decides the colour to be used.\nFor greedy colouring the choice strategy is plain enough. For edge \\(e = uv\\) in graph \\(G\\) we choose the first colour from a palette of colours which is not used on edges incident with either vertex \\(u\\) or vertex \\(v\\). The implementation, below, is made especially simple by Python’s Sets.\ndef choice_greedy(G, e, palette):\n    used_colours = used_at(G, e[0]).union(used_at(G, e[1]))\n    available_colours = set(palette).difference(used_colours)\n    return available_colours.pop()\nHere used_at(G, u) is a function that returns a Set of all colours used on edges incident with u in G. So, via the union operation on Sets, used_colours becomes the set of colours used on edges incident with end-vertices of e. The returned colours is then the colour on the top of available_colours, the set difference of palette and used_colours."
  },
  {
    "objectID": "posts/2014-09-26-greedy-edge-colouring-of-small-graphs/index.html#edge-colouring-small-graphs",
    "href": "posts/2014-09-26-greedy-edge-colouring-of-small-graphs/index.html#edge-colouring-small-graphs",
    "title": "Greedy Edge Colouring of Small Graphs",
    "section": "Edge-Colouring Small Graphs",
    "text": "Edge-Colouring Small Graphs\nThe implementation described in the previous section has been put into a script that processes graphs in graph6 format and returns, not the edge-colouring, but the number of colours used. For example, the number of colours used in a greedy edge-colouring of the Petersen graph is four:\n$ echo ICOf@pSb? | edge_colouring.py\n4\nAs in earlier posts on vertex-colouring we now consider the set of all non-isomorphic, connected, simple graphs and study the average case performance of our colouring method on this set. For vertex-colouring, parallel edges have no effect on the chromatic number and thus the set of simple graphs is the right set of graphs to consider. For edge-colouring we ought to look at parallel edges and thus the set of multigraphs because parallel edges can effect the chromatic index. We will save this case for a future post.\nAlso in common with earlier posts, here we will use Drake as the basis for our simulation. The hope being that others can reproduce our results by downloading our Drakefile and running it.\nWe continue to use geng from nauty to generate the graph data we are studying. For example, to colour all non-isomorphic, connected, simple graphs on three vertices and count the colour used:\n$ geng -qc 3 | edge_colouring.py\n2\n3\nSo, of the two graphs in question, one (\\(P_{3}\\)) has been coloured with two colours and the other (\\(K_{3}\\)) has been coloured with three colours.\nAs with vertex-colouring, the minimum number of colours in a proper edge-colouring of a graph \\(G\\) is \\(\\Delta(G)\\). In contrast, though, by Vizing’s theorem, at most one extra colour is required.\nTheorem (Vizing)\n\n\\(\\chi^{\\prime}(G) \\leq 1 + \\Delta(G)\\)\n\nA graph \\(G\\) for which \\(\\chi^{\\prime}(G) = \\Delta(G)\\) is called Class One. If \\(\\chi^{\\prime}(G) + 1\\) then \\(G\\) is called Class Two. By Vizing’s theorem every graph is Class One or Class Two. \\(P_{3}\\) is an example of a graph that is Class One and \\(K_{3}\\) is an example of a Class Two graph.\nVizing’s theorem says nothing, however, about how many colours our greedy colouring program will use. We might, though, consider it moderately successful were it to use not many more than \\(\\Delta(G)\\) colours on average.\nSo we are going to consider the total number of colours used to colour all graphs of order \\(n\\) as a proportion of the total maximum degree over the same set of graphs.\nTo compute total number of colours used we follow this tip on summing values in the console using paste and bc:\n$ geng -qc 3\n | edge_colouring.py\n | paste -s -d+\n | bc\n5\nTo compute maximum degrees we depend upon the maxdeg program for gvpr. This means that we have to pipe the output of geng through listg to convert it into DOT format:\n$ geng -qc 3\n | listg -y\n | gvpr -fmaxdeg\nmax degree = 2, node 2, min degree = 1, node 0\nmax degree = 2, node 0, min degree = 2, node 0\nThe output from maxdeg contains much more information than we need and so we need to pipe the output through sed to strip out the maximum degrees:\n$ geng -qc 3\n | listg -y\n | gvpr -fmaxdeg\n | sed -n 's/max degree = \\([0-9]*\\).*/\\1/p'\n2\n2\nNow, piping through paste and bc as before, we find the total over all graphs of the maximum degrees:\n$ geng -qc 3\n | listg -y\n | gvpr -fmaxdeg\n | sed -n 's/max degree = \\([0-9]*\\).*/\\1/p'\n | paste -s -d+\n | bc\n4\nPerhaps surprisingly, with this approach, we find a relatively small discrepancy between the total number of colours used and the total maximum degree. For example, for \\(n = 5\\) (below) the discrepancy is 18 or 25%.\n$ time geng -qc 5\n | edge_colouring.py\n | paste -s -d+\n | bc\n90\n\nreal    0m0.416s\nuser    0m0.328s\nsys 0m0.068s\n$ time geng -qc 5\n | listg -y\n | gvpr -fmaxdeg\n | sed -n 's/max degree = \\([0-9]*\\).*/\\1/p'\n | paste -s -d+\n | bc\n72\n\nreal    0m0.014s\nuser    0m0.004s\nsys 0m0.004s\nFor \\(n = 10\\) the discrepancy is 9189586, or less than 12% of the total of maximum degrees.\n$ time geng -qc 10\n | edge_colouring.py\n | paste -s -d+\n | bc\n87423743\n\nreal    135m6.838s\nuser    131m38.614s\nsys 0m12.305s\n$ time geng -qc 10\n | listg -y\n | gvpr -fmaxdeg\n | sed -n 's/max degree = \\([0-9]*\\).*/\\1/p'\n | paste -s -d+\n | bc\n78234157\n\nreal    48m52.294s\nuser    51m43.042s\nsys 0m12.737s"
  },
  {
    "objectID": "posts/2014-09-26-greedy-edge-colouring-of-small-graphs/index.html#results",
    "href": "posts/2014-09-26-greedy-edge-colouring-of-small-graphs/index.html#results",
    "title": "Greedy Edge Colouring of Small Graphs",
    "section": "Results",
    "text": "Results\nWe repeated the experiment described in the previous section for all values of \\(n\\) from 2 to 10. The results are presented in the plot below which is based on Matplotlib basic plotting from a text file.\n\n\n\nA bar plot with graph order on the x-axis (going from 2 to 10) and number of colours divided by maximum degree on the y-axis (going from 0 to 2). The bar at 2 on the x-axis has height one and therefore the total number of colours used by a greedy strategy for all graphs of order 2 is equal to the total maximum degree over all those graphs. All of the bars are between 1 and 1.5. Apart from bars 2 and 4, all others are greater than 1, indicating that more colours are needed on graphs of those order than the sum of maximum degrees of all graphs of that order. The heighest bars are for orders 3 and 5.\n\n\nFor all orders the total number of colours used by our greedy method is between 1 and 1.5 times the total maximum degree. There also seems to be a tendancy towards a smaller proportion for larger values of \\(n\\). Two theoretical results are relevant here.\nThe first is Shannon’s theorem which concerns the chromatic index of multigraphs:\nTheorem (Shannon)\n\n\\(\\chi^{\\prime}(G) \\leq \\frac{3\\Delta(G)}{2}\\)\n\nShannon’s theorem applies for our experiment because every simple graph is a multigraph with maximum multiplicity 1. An interesting experiment is to see if the results of the above experiment extend to multigraphs. Shannon’s theorem guarantees that for some colouring method it is possible but says nothing about the performance of our specific method.\nA result which is relevant to the second observation, that the proportion tends to 1, concerns the distribution of simple graphs among Class One and Class Two.\nTheorem (10.5 from Chartrand and Zhang (2008))\n\nAlmost every graph is Class One, that is \\(\\lim_{n \\rightarrow \\infty}\\frac{|G_{n,1}|}{|G_{n}|} = 1\\)\n\nwhere \\(G_{n}\\) denotes the set of graphs of order \\(n\\) and \\(G_{n, 1}\\) is the set of Class One graphs of order \\(n\\).\nSo we have good reason to hope that, on average, with larger sets of simple graphs we use fewer colours on average.\nIn the source code section below there is a Drakefile which should reproduce this plot from scratch (provided that the required software is installed)."
  },
  {
    "objectID": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html",
    "href": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html",
    "title": "Improved Greedy Colouring of Small Graphs",
    "section": "",
    "text": "In the previous post we conducted a small experiment to compare the total number of colours used by the greedy vertex colouring algorithm on a collection of small graphs. The aim of that experiment was to see whether, over a large number of graphs, the total number of colours used by different degree orderings was significant. The tool we used was NetworkX. In this post we revisit this experiment with Culberson’s colouring programs.\nAs Culberson’s implementation of the greedy colouring algorithm works with graphs in Dimacs format we need to first generate a collection of small graphs in that format. Fortunately, on the homepage of Brendan McKay there is a large collection of combinatorial data, including small graphs up to order 10. These graphs are in graph6 format but translating a graph from graph6 to Dimacs format is not too difficult thanks to some tools written by McKay for working with graphs in graph6 format.\nSo this is what we are going to do:"
  },
  {
    "objectID": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#convert-from-graph6-to-dimacs",
    "href": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#convert-from-graph6-to-dimacs",
    "title": "Improved Greedy Colouring of Small Graphs",
    "section": "Convert from graph6 to Dimacs",
    "text": "Convert from graph6 to Dimacs\nThe graph6 format is a format devised by Brendan McKay for the nauty {% cite McKay201494 %} graph isomorphism software. In this post we won’t attempt to describe how this format is defined. For further information see the graph6 and sparse6 graph formats page on McKay’s homepage. Gordon Royle also has some useful information about graph6 and sparse6 formats on his homepage.\nThe program listg (and its companion showg) which belongs to the nauty project can display graph6 graphs in various human readable formats. One format which is easy to convert into other formats is the edge format.\n$ curl -s http://cs.anu.edu.au/~bdm/data/graph2.g6\\\n  | listg -e\n\nGraph 1, order 2.\n2 0\n\n\nGraph 2, order 2.\n2 1\n0 1\nSo in graph2.g6 there are two graphs. The first graph has 2 nodes and 0 edges. The second graph has 2 nodes and 1 edge. The edge joins vertices 0 and 1.\nTo convert one of these files into a file of graphs in Dimacs format we use a combination of Sed and AWK. A Sed one-liner can convert a list of edges of the form x y into the x -- y form used in Dimacs. AWK will enable us to process the file of graphs in the above edge-list format and apply to Sed one-liner to each graph. The Sed one-liner in question is:\nsed -r -e 's/([0-9]+) ([0-9]+)/ e \\1 \\2\\n/g' $1\nNow if we think of one of BDMs files as being made of records, each of which is a graph and consists of three lines, the third of which is the list of edges then we can use AWK to convert this into a file of DOT format graphs like so:\nawk -f e2dimacs.awk output.txt &gt; result.txt\nwhere e2dimacs.awk is the following little snippet:\nBEGIN { FS = \"\\n\"; RS = \"\" }\n      { print \"p edge \" $2 }\n      { cmd=\"echo \" $3 \" | e2dimacs\"; system(cmd) }\nand the e2dimacs command is the above Sed one-liner.\nPutting everything together into one pipeline:\n$ curl -s http://cs.anu.edu.au/~bdm/data/graph2.g6\\\n  | listg -e\\\n  | awk -f e2dimacs.awk\n\np edge 2 0\n\np edge 2 1\n e 0 1"
  },
  {
    "objectID": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#split-into-individual-files",
    "href": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#split-into-individual-files",
    "title": "Improved Greedy Colouring of Small Graphs",
    "section": "Split into individual files",
    "text": "Split into individual files\nUnfortunately, greedy expects that an input file contains a single graph to be coloured. This means that if we want to colour a collection of graphs in one file we have to split that file into many. One of the easiest methods is to use AWK.\nSuppose we had redirected the output from the last command of the previous section into a file graph2.g6 then the following command\nawk -f dimacs_split.awk graph2.dimacs\nwith dimacs_split.awk being the AWK program\nBEGIN { FS = \"\\n\"; RS = \"\"; n=0; }\n      { print &gt;&gt; n\".dimacs\"; n++; }\nCreates two files 0.dimacs and 1.dimacs, containing the first and second graph from the original graph6 file but now converted in Dimacs format."
  },
  {
    "objectID": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#colour-with-greedy",
    "href": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#colour-with-greedy",
    "title": "Improved Greedy Colouring of Small Graphs",
    "section": "Colour with greedy",
    "text": "Colour with greedy\nAt this point we have a collection of graphs each in a file of its own. We want to iterate all such files and run greedy with a specific ordering. This is easy if we know how many graphs are contained in the collection. We can just create a loop of the write length in Bash and at each step of the loop we call ccli with the correct parameters and the filename based on a loop index.\nfor n in {0..10};\\\ndo\\\n  ccli greedy --type=simple --ordering=inorder $n.dimacs;\\\ndone"
  },
  {
    "objectID": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#compute-colouring-numbers",
    "href": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#compute-colouring-numbers",
    "title": "Improved Greedy Colouring of Small Graphs",
    "section": "Compute colouring numbers",
    "text": "Compute colouring numbers\nThe output of calling greedy on a file n.dimacs is a file n.dimacs.res in the same folder as the first file and containing the colouring data. The line preceding the colouring itself also contains the number of colours used and we can extract this number using another Sed one-liner:\nsed -n 's/CLRS \\([0-9]*\\) [A-Z a-z = 0-9 .]*/\\1/p' *.dimacs.res\nThe file argument here expands to a list of all files with the suffix .dimacs.res. The output is then a list of numbers, each a number of colours used in a certain colouring. We want to total all of these numbers. There are several different ways of summing numbers in a file. One convenient approach combines the paste and bc commands. The following pipeline will find all colouring numbers for a collection of files and return the total number of colours used.\nsed -n 's/CLRS \\([0-9]*\\) [A-Z a-z = 0-9 .]*/\\1/p' *.dimacs.res\\\n| paste -s -d\"+\"\\\n| bc"
  },
  {
    "objectID": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#experiment-results",
    "href": "posts/2014-06-27-improved-greedy-colouring-of-small-graphs/index.html#experiment-results",
    "title": "Improved Greedy Colouring of Small Graphs",
    "section": "Experiment Results",
    "text": "Experiment Results\nWe put all of the steps together into a simulation. This simulation went through all graphs of order at most 8 and computed the total number of colours used by the greedy algorithm using four different orderings. The results are given in the table below.\n\n\n\nordering\norder \\[\\leq 7\\]\norder \\[\\leq 8\\]\n\n\n\n\nin order\n3732\n42603\n\n\nrandom order\n3906\n44770\n\n\ndescending degree\n3616\n41102\n\n\nascending degree\n3965\n42181\n\n\n\nAs before we can see that descending degree is the best way to go, at least for graphs of order at most 8."
  },
  {
    "objectID": "posts/2014-06-20-strategies-for-greedy-vertex-colouring/index.html",
    "href": "posts/2014-06-20-strategies-for-greedy-vertex-colouring/index.html",
    "title": "Strategies for Greedy Vertex Colouring",
    "section": "",
    "text": "In the previous post we showed that a greedy vertex colouring of a graph \\(G\\) uses at most \\(\\Delta(G) + 1\\) colours. This sounds good until we realise that graphs can have chromatic number much lower than the maximum degree.\nThe crown graphs, sometimes called Johnson graphs are complete bipartite graph \\(K_{2n, 2n}\\) with a one-factor removed.\nCrown graphs are bipartite and hence 2-colourable.\nHowever, the maximum degree of a crown graph \\(G\\) of order \\(2n\\) is \\(n - 1\\) and, with some vertex orderings, a greedy colouring of \\(G\\) uses \\(\\Delta(G) + 1 = n\\) colours.\nWe might ask, what vertex orderings lead to colourings with fewer colours? The following theorem of Dominic A. Welsh and Martin B. Powell is pertinent.\nTheorem (Welsh, Powell)\nLet \\(G\\) be a graph of order \\(n\\) whose vertices are listed in the order \\(v_{1}, v_{2}, ... v_{n}\\) so that \\(\\operatorname{deg} v_{1} \\geq \\operatorname{deg} v_{2}\\geq \\dots \\geq\\operatorname{deg} v_{n}\\). Then \\(\\chi(G) \\leq 1 + \\min_{1 \\leq i \\leq n}\\{\\max{\\{i - 1, \\operatorname{deg} v_{i}\\}\\}} = \\min_{1\\leq i\\leq n}\\{\\max{\\{i, 1 + \\operatorname{deg} v_{i}}\\}\\}\\)\nIn the case of regular graphs, like the crown graphs, this theorem reduces to the \\(\\Delta(G) + 1\\) upper-bound on the chromatic number. For graphs that are not regular this result suggests that we can get a tighter bound on the chromatic number by considering orderings of vertices in non-increasing degree order.\nThe Grotzsch graph is an irregular graph that plays an important role in the study of graph colouring. Unfortunately, it is not one of the named graphs in NetworkX. We can, however, download it from the House of Graphs as a file in graph6 format. Then we can use the read_graph6 function to read it into a NetworkX graph.\nWe can compute the bound from the Welsh-Powell theorem.\nwhich is a significant improvement over the \\(\\Delta(G) + 1 = 6\\) bound. In fact, the chromatic number of the Grotzsch graph is 4 and a greedy colouring with 4 colours can be found.\nWe might suspect then that a good vertex colouring strategy is greedy colouring with vertices in non-increasing degree order. In the next section we devise a small test of this claim."
  },
  {
    "objectID": "posts/2014-06-20-strategies-for-greedy-vertex-colouring/index.html#greedy-strategies-for-colouring-small-graphs",
    "href": "posts/2014-06-20-strategies-for-greedy-vertex-colouring/index.html#greedy-strategies-for-colouring-small-graphs",
    "title": "Strategies for Greedy Vertex Colouring",
    "section": "Greedy Strategies for Colouring Small Graphs",
    "text": "Greedy Strategies for Colouring Small Graphs\nNetworkX comes with a collection of all unlabelled, undirected graphs on seven or fewer vertices based on Read and Wilson (2005) . The experiment below colours every graph in this collection using four different vertex orderings: in order, random order, decreasing degree order and increasing degree. In order is the order ordering of vertices in the data representation of the graph. In the case of NetworkX this just means that we colour vertices in the order they appear in G.nodes(). Random order just means that we first shuffle this list using random.shuffle. The other orderings are defined by the degree_order function below.\ndef degree_order(G, reverse = False):\n    \"\"\"Vertices of G, ordered by degree.\"\"\"\n    return sorted(G.nodes(), key = G.degree, reverse = reverse)\nIn the following code extract we iterate over the graphs in graphs_atlas_g() colouring each graph with each of the four above mentioned vertex ordering strategies. We calculate the number of colours used by each colouring and, at the end, we print out the totals of these numbers over all graphs.\nimport networkx as nx\nimport random\n\ngraphs = nx.graph_atlas_g()\n\ncolours_used = {'inorder': 0, 'random': 0, 'decdeg': 0, 'incdeg': 0}\n\nfor G in graphs:\n\n    nodes = G.nodes()\n    inorder_nodes = nodes\n    random_nodes = random.shuffle(nodes)\n    \n    orderings = {'inorder': nodes,\n                 'random': random_nodes,\n                 'decdeg': degree_order(G, reverse = True),\n                 'incdeg': degree_order(G)}\n    \n    for ordering in orderings:\n        vcolour(G, nodes = orderings[ordering])\n        colours_used[ordering] += ncolours(G)\n        clear_colouring(G)\n\n\n\nOrdering\nColours used\n\n\n\n\nin order\n4255\n\n\nrandom order\n4252\n\n\ndescending degree order\n4120\n\n\nascending degree order\n4468\n\n\n\nWe can see that the best ordering to use in this case is the ordering claimed in Welsh and Powell’s theorem. Ordering vertices by their degree from highest to lowest. The worst case is the reverse ordering and randomised and natural orderings lie somewhere in between."
  },
  {
    "objectID": "posts/2014-10-17-euler-paths/index.html",
    "href": "posts/2014-10-17-euler-paths/index.html",
    "title": "Euler Paths",
    "section": "",
    "text": "One of the oldest problems in graph theory concerns the Eastern Prussia old city of Königsberg. In that city was an island around which the river Pregel flowed in two branches. Seven bridges crossed the river to enable people to cross between mainland and island. A drawing of the river, bridges and island is shown below.\nAt some point the question of whether it was possible to devise a tour of the city to cross every one of the bridges once and once only was raised. In 1736, Euler showed that no such route is possible.\nEuler explained his solution in Euler (1741) which has been translated in the first chapter of Biggs, Lloyd, and Wilson (1986) . The original version “Solutio Problematis Ad Geometriam Situs Pertinentis” is available for download from the MAA Euler Archive.\nThe goal of this post is to reproduce some ideas from Euler’s paper in computer language, specifically for the Maxima computer algebra system. We describe an implementation of multigraphs in Maxima and an approach to deciding whether a path in a multigraph is an Euler path or not. In a future post we will revisit this topic and discuss searching multigraphs for Euler paths."
  },
  {
    "objectID": "posts/2014-10-17-euler-paths/index.html#multigraphs-in-maxima",
    "href": "posts/2014-10-17-euler-paths/index.html#multigraphs-in-maxima",
    "title": "Euler Paths",
    "section": "Multigraphs in Maxima",
    "text": "Multigraphs in Maxima\nMaxima comes with a module for working with graphs. Unfortunately, the Maxima graphs module requires graphs to be simple, having no parallel edges and no loops. The graph which arises in the Königsberg bridges problem, however, is not simple.\nOne way to represent a multigraph is as a pair \\(G = (V, E)\\) where \\(V\\) is a set of vertices and \\(E\\) is a set of edges. An edge ,in this context, is a pair \\((e, \\{u, v\\})\\) where \\(e\\) is an edge-label and \\(u, v\\) are the end-vertices of \\(e\\). This representation allows edges to have the same ends and only to differ in label. Loops in this setting would be pairs of the form \\((e, u)\\) or \\((e, \\{u\\})\\). As none of the graphs we consider here contain loops we ignore the added complications of allowing loops.\nMaxima makes it easy to create new simple data structures. The defstruct function adds a new structure to Maxima’s list of user-defined structures. A structure in Maxima has the same syntax as a function signature. The function name becomes the name of a new structure and its arguments become fields of structures of defined with new and can then be accessed with the @ syntax.\nFor example, we can define a graph structure like so:\n(%i) defstruct(graph(V, E))$\nThen a multigraph representing the bridges of Königsberg can be created like so:\n(%i) konigsberg: new(graph({A,B,C,D},\n                          {[a,{A,B}],\n                           [b,{A,B}],\n                           [c,{A,C}],\n                           [d,{A,C}],\n                           [e,{A,D}],\n                           [f,{B,D}],\n                           [g,{C,D}]}))$\nThe vertices of this multigraph are the regions of land, either mainland or island:\n(%i) konigsberg@V;\n(%o)                           {A, B, C, D}\nThe edges are bridges. The label of an edge being the label of the bridge in Euler’s diagram and the ends are the vertices (regions of land) joined by the bridge in question:\n(%i) konigsberg@E;\n(%o) [[a, {A, B}], [b, {A, B}], [c, {A, C}], [d, {A, C}],\n                    [e, {A, D}], [f, {B, D}], [g, {C, D}]]\nTo access to the ends of a specific edge use the assoc function which gives a list or set of pairs the interface of an associative structure:\n(%i) assoc(a, konigsberg@E);\n(%o)                               {A, B}"
  },
  {
    "objectID": "posts/2014-10-17-euler-paths/index.html#euler-paths-in-maxima",
    "href": "posts/2014-10-17-euler-paths/index.html#euler-paths-in-maxima",
    "title": "Euler Paths",
    "section": "Euler Paths in Maxima",
    "text": "Euler Paths in Maxima\nA path in Biggs, Lloyd, and Wilson (1986) is defined as a sequence of vertices and edges \\(v_{0},e_{1},v_{1},e_{2},v_{2},\\ldots,v_{r-1},e_{r},v_{r}\\) in which each edge \\(e_{i}\\) joins vertices \\(v_{i-1}\\) and \\(v_{i}\\) \\((1\\leq i\\leq r)\\). An Euler path is a path for which \\(r = |E|\\), where \\(|E|\\) is the size of the multigraph.\nIn Maxima paths (and non-paths) can be represented by lists of symbols. To distinguish those lists of symbols which truly represent a path in a graph we will have to check the defining properties of a path. Namely we have to be sure that\n\nevery \\(v_{i}\\) is a vertex of \\(G\\),\nevery \\(e_{i}\\) is a edge of \\(G\\),\nevery \\(e_{i}\\) is an edge of \\(G\\) which joins vertices \\(v_{i-1}\\) and \\(v_{i}\\) of \\(G\\).\n\nAs the third condition subsumes the other two and as we are only concerned with correctness here and not, yet, efficiency we can ignore the first two conditions and only check the third one.\nSo if \\(P\\) is a list of symbols then \\(P\\) is a path of multigraph \\(G\\) if and only if\n{P[i-1], P[i+1]} = assoc(P[i], G@E))\nholds for all i from 2 to (length(P) - 1)/2 [lists in Maxima being indexed from 1]. This condition expresses the fact that symbols adjacent to the ith symbol are the ends of the edge represented by that symbol in some order. Notice that this condition requires that the list has the vertex-edge-vertex structure of a path.\nNow we can define a function path(G, P) that decides whether \\(P\\) is a path in \\(G\\) or not:\npath(G, P):= block(\n [result: true],\n for i: 2 step 2 thru (length(P)-1) do (\n   result: result and is({P[i-1], P[i+1]} = assoc(P[i], G@E))\n ),\n return(result)\n)$\nWith this function available, testing for Euler paths is only a matter of testing whether a path has length equal 2*length(G@E) + 1:\neuler_path(G, P):= (\n is(path(G, P)) and is(length(P) = 2*length(G@E) + 1)\n)$\nAs a test of this function we check that an example of an Euler path in Euler (1741) really is an Euler path. As the bridges of Königsberg multigraph has on Euler path, Euler considers a fictitious map, shown below:\n\n\n\nConnected Graphs\n\n\nHe claims that \\(EaFbBcFdAeFfCgAhCiDkAmEnApBoElD\\) is an Euler path in this map. We can check by hand but now we can also represent the multigraph in Maxima and check using the above implementation of euler_path:\n(%i) eulersberg: new(graph({A,B,C,D,E,F},\n                          {[a,{E,F}],\n                           [b,{B,F}],\n                           [c,{B,F}],\n                           [d,{A,F}],\n                           [e,{A,F}],\n                           [f,{C,F}],\n                           [g,{A,C}],\n                           [h,{A,C}],\n                           [i,{C,D}],\n                           [k,{A,D}],\n                           [l,{D,E}],\n                           [m,{A,E}],\n                           [n,{A,E}],\n                           [o,{B,E}],\n                           [p,{A,B}]}))$\n(%i) s: \"EaFbBcFdAeFfCgAhCiDkAmEnApBoElD\"\n(%i) journey: map(eval_string, charlist(s))$\n(%i) euler_path(eulersberg, journey);\n(%o)                                true"
  },
  {
    "objectID": "posts/2023-05-04-generating-examples-of-maximal-room-squares-in-r/index.html",
    "href": "posts/2023-05-04-generating-examples-of-maximal-room-squares-in-r/index.html",
    "title": "Generating Examples of Maximal Room Squares in R",
    "section": "",
    "text": "A Room square of order \\(n\\) and side \\(n − 1\\) on an \\(n\\)‐element set \\(S\\) is an \\(n - 1 \\times n - 1\\) array filled with \\(n\\) different symbols in such a way that:\nA partial Room square of order \\(n\\) and side \\(n − 1\\) on an \\(n\\)‐element set \\(S\\) is an \\(n - 1 \\times n - 1\\) array satisfying property (1) above, and also\nA partial Room square is maximal if no further pair of elements of \\(S\\) can be placed into any unoccupied cell of \\(F\\) without violating the conditions (1), (4), (5)."
  },
  {
    "objectID": "posts/2023-05-04-generating-examples-of-maximal-room-squares-in-r/index.html#greedy1",
    "href": "posts/2023-05-04-generating-examples-of-maximal-room-squares-in-r/index.html#greedy1",
    "title": "Generating Examples of Maximal Room Squares in R",
    "section": "greedy1",
    "text": "greedy1\nThe algorithm greedy1 visits each cell in a predetermined order and places the first available pair of symbols into the cell, provided that doing so does not violate the conditions of creating a partial Room square.\nR &lt;- greedy1(6)\nplot_room_square_labs(R)\n\nIn this plot, the colors indicate the sequence in which the cells were filled. Specifically, lighter colors represent cells that were filled earlier in the process, while darker colors represent cells that were filled later.\nis_maximal_proom(R)\n#&gt; [1] TRUE\nHere are a few more examples of maximal partial Room squares created by greedy1."
  },
  {
    "objectID": "posts/2023-05-04-generating-examples-of-maximal-room-squares-in-r/index.html#greedy2",
    "href": "posts/2023-05-04-generating-examples-of-maximal-room-squares-in-r/index.html#greedy2",
    "title": "Generating Examples of Maximal Room Squares in R",
    "section": "greedy2",
    "text": "greedy2\nThe algorithm greedy2 iterates through all pairs of symbols in a predetermined order and places the next available pair into the first empty cell, provided that doing so does not violate the conditions of creating a partial Room square.\nR &lt;- greedy2(6)\nplot_room_square_labs(R)\n\nis_maximal_proom(R)\n#&gt; [1] TRUE\nHere are a few more examples of maximal partial Room squares created by greedy2."
  },
  {
    "objectID": "posts/2023-05-04-generating-examples-of-maximal-room-squares-in-r/index.html#code",
    "href": "posts/2023-05-04-generating-examples-of-maximal-room-squares-in-r/index.html#code",
    "title": "Generating Examples of Maximal Room Squares in R",
    "section": "Code",
    "text": "Code\nhttps://github.com/MHenderson/maximal-room-squares"
  },
  {
    "objectID": "posts/2014-05-02-basic-graph-drawing/index.html",
    "href": "posts/2014-05-02-basic-graph-drawing/index.html",
    "title": "Basic Graph Drawing",
    "section": "",
    "text": "Graph drawing in NetworkX is handled by the draw function. Layouts are generated through functions like circular_layout and spring_layout, providing coordinate mappings that integrate with the draw function, enabling the rendering of visually appealing graphs.\nEach layout has a draw_ function. For instance, the circular layout can be accessed by the draw_circular function, while the spring layout is available through the draw_spring function.\nIn the next section, we will demonstrate the draw function with various layout functions, demonstrating how to use them for graph visualization.\n\nDrawing the Petersen Graph with NetworkX\nAs with all work involving NetworkX, begin by importing the package.\nimport networkx as nx\nNetworkX makes many named graphs available. For example, the Petersen graph can be generated by the petersen_graph function.\nG = nx.petersen_graph()\nTo visualize the Petersen graph with a circular layout, you can use the draw function by providing it with vertex coordinates generated from the circular_layout function. This layout function takes the graph as its parameter and outputs the coordinates of the vertices, arranging them in a circular pattern. By passing these coordinates to the draw function, the Petersen graph will be rendered in a circular layout, resulting in a visually appealing representation.\nnx.draw(G, nx.circular_layout(G))\n\n\n\n\n\nInstead of using the draw function in conjunction with the circular_layout function we can use the draw_circular convenience function.\nThe draw function and all of the draw_ functions can be configured to produce graph drawings with different visual properties. Keyword parameters can be specified to customise things like node colours, edge widths and whether the graph is displayed with labels or not.\nnx.draw_circular(G, with_labels=False, node_color='black')\n\n\n\n\n\nTo enhance reusability across multiple graphs, consolidating all configuration options into a dictionary and subsequently passing this dictionary as a parameter to the relevant layout function proves advantageous. This approach streamlines the process of managing and applying configuration settings for various graphs efficiently.\noptions = {\n 'with_labels': False,\n 'node_color': 'black',\n 'node_size': 200,\n 'width': 3,\n}\n\nnx.draw_circular(G, **options)\n\n\n\n\n\nThis drawing is not easily recognised as a drawing of the Petersen graph. A more familiar drawing shows one of the five cycles in the shape of a regular pentagon with another five cycle as a star in the interior joined to the outer cycle by five spokes. To achieve this layout in NetworkX use the shell layout algorithm.\nThe draw_shell function takes an optional nlist keyword argument. The elements of the list are lists of vertices. The vertices will be arranged in concentric shells according to the elements of these lists. Figuring out which vertices lie in the outer shell and which are in the inner shell, along with their respective orderings, requires a little experimentation.\nnx.draw_shell(G, nlist=[range(5, 10), range(5)], **options)\n\n\n\n\n\nNetworkX has the following layout algorithms.\n\nCircular\nShell\nSpring\nSpectral\nRandom\nGraphviz (through pygraphviz)\n\nWe have seen already examples of the circular and shell layouts. The next figure reproduces the shell and circular drawings of the Petersen graph we have already seen along with examples of spring and spectral layouts.\nplt.subplot(221)\nnx.draw_circular(G, **options)\n\nplt.subplot(222)\nnx.draw_shell(G, nlist=[range(5, 10), range(5)], **options)\n\nplt.subplot(223)\nnx.draw_spectral(G, **options)\n\nplt.subplot(224)\nnx.draw_spring(G, **options)\n\n\n\n\n\nThe plt.subplot command takes an integer argument whose first two digits are interpreted as a number of rows and columns in a rectangular grid layout. The third argument is interpreted as the position of the current figure in the grid. Grid numbering starts in the top-left corner and proceeds right and down to the bottom-right corner.\n\n\nDrawing Graphs with More Nodes\nThe options we have chosen so far have been suitable for graphs with a few nodes. When drawing larger graphs it makes sense to choose smaller node sizes and thinner edges so that the various elements of the graph can be easily distinguished.\noptions_1 = {\n 'with_labels': False,\n 'node_color': 'black',\n 'node_size': 50,\n 'width': 1,\n}\nAs with the earlier drawing of the Petersen graph the nodes for different layers of the drawing of the dodecahedral graph below were found through experimentation.\nG = nx.dodecahedral_graph()\nnx.draw_shell(G, nlist = [[2,3,4,5,6],[8,1,0,19,18,17,16,15,14,7],[9,10,11,12,13]], **options_1)\n\n\n\n\n\n\n\nDrawing Graphs with Many Nodes\nIf a graph has many nodes then there is a risk, in particular with circular or shell layouts, of node boundaries overlapping. Choosing small node sizes is a natural remedy. When choosing very small nodes edges must also be made very thin so that node-edge intersections can be seen. As thin edges appear grey and it makes sense choose grey nodes to match.\noptions_2 = {\n 'with_labels': False,\n 'node_color': 'grey',\n 'node_size': 10,\n 'linewidths': 0,\n 'width': 0.1,\n}\nG = nx.barabasi_albert_graph(100, 3)\nnx.draw_circular(G, **options_2)\n\n\n\n\n\n\n\nDrawing Graphs with Many Edges\nDrawing graphs with many edges requires further tinkering with layout options. When there are many edges it can be difficult to distinguish different edges and see which vertices are the ends of a particular edge. Increasing transparency by lowering alpha may have some benefit.\noptions_3 = {\n 'with_labels': False,\n 'node_color': 'grey',\n 'node_size': 10,\n 'linewidths': 0,\n 'width': 0.1,\n 'alpha': 0.3\n}\n\nG = nx.complete_bipartite_graph(25, 26)\nnx.draw_shell(G, nlist=[range(0, 25), range(25, 51)], **options_3)\n\n\n\n\n\nAdmittedly, this drawing conveys little information about the graph. It is hard even to see which nodes in the inner shell are connected to nodes in the outer shell or if there are any connections between nodes in the inner shell. About the only information we can interpret is that nodes in the outer shell appear not to be joined to other vertices in the outer shell. But it serves as an example of the kind of issues that can arise when drawing graphs with many edges.\n\n\nImporting Layouts from Gephi\nNaturally, some of the problems encountered above are due to poorly chosen layouts. Better layouts can reduce problems of identifying nodes and edges. Even better layouts can help to highlight structural properties and symmetries of graphs.\nG = nx.random_lobster(100, 0.9, 0.9)\nnx.draw_spring(G, iterations=10000, **options_2)\n\n\n\n\n\nIn a earlier post we talked about how to use Gephi to find nice layouts of large lobster graphs. As an alternative to using NetworkX’s layout algorithms we can export our graph, use Gephi to find a suitable layout and then import the graph data back (now augmented with coordinate information) and use the raw drawing ability of NetworkX to render the graph with this layout.\nG = nx.read_graphml('lobster.graphml')\npos = dict([(v,(G.node[v]['x'], G.node[v]['y'])) for v in G.nodes()])\nNetworkX loads the graph as a directed graph and will draw directed edges with arrows unless we set the arrows keyword argument to False.\nnx.draw(G, pos, arrows=False, **options_2)\n\n\n\n\n\nThis drawing is an improvement on the previous one. The chosen layout almost succeeds in conveying both the planarity and lobsterity of the graph. With a little manual adjustment we could probably eliminate all edge-crossings. Other nice properties of this layout are that there are only a few different edge lengths and nodes are evenly distributed over a symmetrical area.\n\n\nCode\nCode for this blog post is available at the following repository: https://github.com/MHenderson/graph-drawing"
  },
  {
    "objectID": "posts/2014-08-29-chromatic-indices-of-small-graphs/index.html",
    "href": "posts/2014-08-29-chromatic-indices-of-small-graphs/index.html",
    "title": "Chromatic Indices of Small Graphs",
    "section": "",
    "text": "In this post we compute the chromatic index of all graphs on at most nine vertices with ten edges or fewer.\nAs in Colouring Small Graphs and Colouring Small Graphs: Update the source code for this experiment is presented as a Drakefile. As this Drakefile very similar to the Drakefiles for those earlier experiments we try to add some value by making several improvements to the quality of the source code in the hope of improving the generalisability of our method and the reproducibility of our results."
  },
  {
    "objectID": "posts/2014-08-29-chromatic-indices-of-small-graphs/index.html#overview",
    "href": "posts/2014-08-29-chromatic-indices-of-small-graphs/index.html#overview",
    "title": "Chromatic Indices of Small Graphs",
    "section": "Overview",
    "text": "Overview\nThe goal is to compute the chromatic indices of all graphs whose order is at most nine. In this experiment we do part of this computation for graphs whose size is at most ten. The reason why we look at graphs with only a small number of edges is that we are using the chromatic program on the line graph \\(L(G)\\) to compute the chromatic index \\(\\chi^{\\prime}(G)\\) of \\(G\\) (justified by the observation that \\(\\chi^{\\prime}(G) = \\chi(L(G))\\)). The chromatic program is slow for graphs on more than ten vertices. Therefore, as the order of \\(L(G)\\) is equal to the size of \\(G\\), we are restricted to graphs of small size.\nAs with the earlier experiments into the chromatic number, we consider connected graphs as a separate case. Also, the sets of graphs, both connected and all graphs, are sets of non-isomorphic graphs.\nSo there are two simulations whose results are presented below.\n\nThe chromatic indices of all non-isomorphic connected simple graphs with order at most nine and size at most ten.\nThe chromatic indices of all non-isomorphic simple graphs with order at most nine and size at most ten.\n\nAs things stand, we have very little in the way of verification of our results other than a little by-hand checking of total counts of graphs compared against data generated by Gordon Royle."
  },
  {
    "objectID": "posts/2014-08-29-chromatic-indices-of-small-graphs/index.html#experimental-details",
    "href": "posts/2014-08-29-chromatic-indices-of-small-graphs/index.html#experimental-details",
    "title": "Chromatic Indices of Small Graphs",
    "section": "Experimental Details",
    "text": "Experimental Details\nThe graph data we use is generated by geng from the gtools collection from nauty. To specify graphs of a specific size using geng we can provide the size as an optional extra argument after the order. For example, to generate all non-isomorphic connected graphs on four vertices with three edges (here piped through listg into circo for visualisation purposes):\n$ geng -qc 4 3 | listg -y | circo -Tsvg -O $options\n \nwhere $options was previously defined as:\n$ options=\"-Nfixedsize=true\\\n           -Nlabel=\\\n           -Nshape=circle\\\n           -Nheight=0.2\\\n           -Nwidth=0.2\\\n           -Nstyle=filled\\\n           -Nfillcolor=black\"\nTo generate graph data with a range of sizes an optional size argument can be given as a range in the form min:max where 0 for the upper bound is interpreted as \\(n \\choose 2\\). For example, to generate all non-isomorphic connected graphs of order four with size at least four:\n$ geng -qc 4 4:0 | listg -y | circo -Tsvg -O $options\n   \nFor the purposes of computing chromatic indices we transform every graph into its line graph. Line graphs can be constructed with the linegraphg program from gtools. For example, the linegraphs of the previous four graphs are:\n$ geng -qc 4 4:0 | linegraphg -q | listg -y | circo -Tsvg -O $options\n   \nThe -q switch for linegraphg, as with geng, suppresses auxiliary output.\nAs we have done in earlier experiments, we take the generated graph data in DOT format and, using csplit, split it across multiple files with one graph per file.\nThe resulting line graph data is then processed by chromatic in the identical manner described in Colouring Small Graphs. The resulting data on the distribution of chromatic numbers (here, interpreted as chromatic indices) is then collated and tabulated, also identically as in the previously mentioned post. That distribution data is presented below in the results section along with two plots whose construction is explained now.\nThe table created by joining together the per-order distributions of chromatic indices is not in the perfect format for plotting with Gnuplot so a Drake rule transforms it into a new tab separated values file with an extra header row added and the final row of column totals removed.\noutput/data.tsv &lt;- output/table.txt\n  head -n-1 $INPUT\\\n  | sed -e '1i X\\t2\\t3\\t4\\t5\\t6\\t7\\t8\\t9\\t' &gt;&gt; $OUTPUT\nAnother rule then transforms the above generated tsv data into a plot. The plotting is done by Gnuplot, implemented as a Drake method exploiting a little hack to pipe a Gnuplot program into Gnuplot.\nplot()\n  echo \"\\\n   clear;\n   reset;\n   set style data histogram;\n   set style histogram columnstacked;\n   set style fill solid border;\n   set boxwidth 0.95 relative;\n   unset key;\n   set term png;\n   set output \\\"$[OUTPUT]\\\";\n   plot for [COL=$[ORDER_MIN]:$[ORDER_MAX]] '$[INPUT]' using COL title columnheader;\n  \" | gnuplot\n\noutput/histogram.png &lt;- output/data.tsv [method:plot]\nThe variables appearing in the Gnuplot program string are all Drake variables. The $INPUT and $OUTPUT variables are the normal automatically generated variables set when the method is called from the rule to which the method is attached. The $ORDER_MIN and $ORDER_MAX variables are set manually inside the Drakefile and are used elsewhere."
  },
  {
    "objectID": "posts/2014-08-29-chromatic-indices-of-small-graphs/index.html#results",
    "href": "posts/2014-08-29-chromatic-indices-of-small-graphs/index.html#results",
    "title": "Chromatic Indices of Small Graphs",
    "section": "Results",
    "text": "Results\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\[n = 2\\]\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\\[\\chi =  2\\]\n0\n1\n2\n1\n2\n1\n2\n1\n\n\n3\n0\n1\n4\n8\n26\n58\n162\n254\n\n\n4\n0\n0\n0\n10\n45\n193\n435\n538\n\n\n5\n0\n0\n0\n2\n21\n80\n187\n215\n\n\n6\n0\n0\n0\n0\n0\n18\n39\n59\n\n\n7\n0\n0\n0\n0\n0\n0\n9\n13\n\n\n8\n0\n0\n0\n0\n0\n0\n0\n4\n\n\n9\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nTotal:\n0\n2\n6\n21\n94\n350\n834\n1084\n\n\n\n\n\n\nConnected Graphs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\[n = 2\\]\n3\n4\n5\n6\n7\n8\n9\n\n\n\n\n\\[\\chi =  2\\]\n0\n1\n3\n5\n10\n15\n26\n37\n\n\n3\n0\n1\n5\n14\n46\n123\n350\n772\n\n\n4\n0\n0\n0\n10\n55\n258\n749\n1476\n\n\n5\n0\n0\n0\n2\n23\n104\n305\n568\n\n\n6\n0\n0\n0\n0\n0\n18\n57\n125\n\n\n7\n0\n0\n0\n0\n0\n0\n9\n22\n\n\n8\n0\n0\n0\n0\n0\n0\n0\n4\n\n\n9\n0\n0\n0\n0\n0\n0\n0\n0\n\n\nTotal:\n0\n2\n8\n31\n134\n518\n1496\n3004\n\n\n\n\n\n\nConnected Graphs"
  },
  {
    "objectID": "posts/2014-07-04-vertex-colouring-by-recursive-removal-of-independent-sets-of-vertices/index.html",
    "href": "posts/2014-07-04-vertex-colouring-by-recursive-removal-of-independent-sets-of-vertices/index.html",
    "title": "Vertex Colouring by Recursive Removal of Independent Sets of Vertices",
    "section": "",
    "text": "The previous two posts were about greedy colouring small graphs. In the first post an implementation of the greedy algorithm in Python with NetworkX was used to colour all graphs on at most 7 vertices. We compared different vertex orderings by counting, for different ordering strategies, the total number of colours used on this set of graphs. In the subsequent post we repeated this experiment and extended it to graphs on at most 8 vertices using Culberson’s colouring programs.\nPerhaps surprisingly, Culberson’s programs did much better than our Python implementation. The most likely explanation is simply that our greedy colouring Python code is broken. Before we can conclude this, though, it is probably a good idea to investigate colouring the same set of graphs using another vertex colouring algorithm.\nThe goal of this post then is to introduce a slightly different approach to graph colouring, the method of recursive independent set removal."
  },
  {
    "objectID": "posts/2014-07-04-vertex-colouring-by-recursive-removal-of-independent-sets-of-vertices/index.html#chromatic-numbers-of-small-graphs",
    "href": "posts/2014-07-04-vertex-colouring-by-recursive-removal-of-independent-sets-of-vertices/index.html#chromatic-numbers-of-small-graphs",
    "title": "Vertex Colouring by Recursive Removal of Independent Sets of Vertices",
    "section": "Chromatic Numbers of Small Graphs",
    "text": "Chromatic Numbers of Small Graphs\nThe minimal total number of colours used in a proper colouring of all graphs on at most seven vertices is 3348, computed from the following table which is found on Gordon Royle’s Small Graphs data page.\n\n\n\npng\n\n\nThe total number of colours used by Culberson’s greedy program with descending degree vertex ordering was 3616. The total number of colours used by the NetworkX-based implementation was 4120.\nThese values differ by 504, which seems quite a large discrepancy as a proportion of the minimum of 3348 colours. What could be the cause? Or is this not a significant discrepancy? It seems to me that there are a few possibilities. The most likely explanations are problems with the data sets used in the experiments or a flaw in our implementation of the greedy algorithm. These possibilities should be eliminated first before embarking on a larger study to decide whether the discrepancy is significant or not.\nWhatever are the reasons for the discrepancy it seems that some testing and verification of both graph data and colourings is in order. Seeing as we have been avoiding this issue in earlier posts it seems like an appropriate time to improve the reliability of our data.\nTo this end, it would be useful to have still more than implementations of vertex colouring. In this post we implement another vertex colouring algorithm based on the idea of recursively extracting a large independent set."
  },
  {
    "objectID": "posts/2014-07-04-vertex-colouring-by-recursive-removal-of-independent-sets-of-vertices/index.html#colouring-by-stable-set-recursion",
    "href": "posts/2014-07-04-vertex-colouring-by-recursive-removal-of-independent-sets-of-vertices/index.html#colouring-by-stable-set-recursion",
    "title": "Vertex Colouring by Recursive Removal of Independent Sets of Vertices",
    "section": "Colouring by Stable Set Recursion",
    "text": "Colouring by Stable Set Recursion\nThe implementation in NetworkX of recursive maximal independent set extraction is very simple because NetworkX implements the algorithm from Boppana and Halldórsson (1992) in the function maximal_independent_set. Notice that this is a maximal independent set algorithm, not a maximum independent set algorithm. So at each level of recursion, we find an approximation to a maximum independent set. With small graphs this approach seems reasonably successful.\nfrom copy import deepcopy\n\ndef __vcolour3__(G, C, level=0):\n    \"\"\"Vertex colouring by recursive maximal independent\n       set extraction.\"\"\"\n    H = deepcopy(G)\n    if (H.number_of_nodes() &gt; 0):\n        V1 = nx.maximal_independent_set(H)\n        for v in V1: C[v]['colour'] = level\n        H.remove_nodes_from(V1)\n        __vcolour3__(H, C, level + 1)\n\ndef vcolour2(G):\n    \"\"\"Interface for vertex colouring by recursive maximal\n       independent set extraction.\"\"\"\n    return __vcolour3__(G, G.node)\nWith the Petersen graph, for example, we find a minimal colouring with three colours:\nimport networkx as nx\n\nP = nx.petersen_graph()\nvcolour2(P)\n\nnx.draw_shell(P, nlist = [range(5,10), range(5)], node_color = colours(P), **options)\n\n\n\npng\n\n\nWith the dodecahedral graph we can find also a minimal 3-colouring although we have to make sure to seed the random number generator suitably.\nimport random\nrandom.seed(0)\n\nsetfigsize(6, 6)\n\nG = nx.dodecahedral_graph()\nvcolour2(G)\nnlist = [[2,3,4,5,6],[8,1,0,19,18,17,16,15,14,7],[9,10,11,12,13]]\nnx.draw_shell(G, nlist = nlist , node_color = colours(G), **options)\n\n\n\npng\n\n\nWe also find a minimal 4-colouring of the Grotzsch graph.\nG = nx.read_graph6('graph_1132.g6')\n\nvcolour2(G)\nnx.draw_circular(G, node_color = colours(G), **options)\n\n\n\npng\n\n\n\nColouring Small Graphs\nFor comparison with the colourings from the previous weeks we colour all graphs on at most seven vertices and count the total number of colours.\nimport networkx as nx\n\ngraphs = nx.graph_atlas_g()\ncolours_used = []\n\nfor G in graphs:\n    vcolour2(G)\n    colours_used.append(ncolours(G))\n    clear_colouring(G)\n\nsum(colours_used)\n4293\nThis value is closer to the larger value of total colours used by our NetworkX based implementation of greedy vertex colouring. In upcoming posts we will return to the question of testing graph data so that we can rule out problems with the graph data used in these experiments."
  },
  {
    "objectID": "posts/2014-04-25-plane-drawings-of-lobsters/index.html",
    "href": "posts/2014-04-25-plane-drawings-of-lobsters/index.html",
    "title": "Plane Drawings of Lobsters",
    "section": "",
    "text": "In this post we demonstrate how to use Gephi to find a nice drawing of a graph with hundreds of vertices.\nA nice drawing here is one with few edge crossings whose nodes are evenly distributed over a fixed area and has a small number of different edge lengths.\n\nLobster graphs\nFrom MathWorld:\n\na lobster is a tree having the property that the removal of leaves leaves a caterpillar\n\nwhere\n\na caterpillar is a tree such that removal of its endpoints leaves a path graph.\n\n\n\n\n\n\nLobsters, being trees, are planar graphs. So plane drawings of small lobsters, like the one above, can be achieved easily. Although this drawing is not particularly elegant one it does possess the dual benefit of highlighting both the planarity and the lobsterity of the graph.\nFor comparison, consider the following drawing of a large lobster graph.\n\n\n\n\n\nIn this drawing neither the planarity nor the lobsterity of the graph are apparent.\nThis lobster graph has 287 vertices and, being a tree, 286 edges was generated in Python using NetworkX.\nThe following command creates a file in Graph Exchange Format (GEXF).\n$ python -c \"import networkx as nx;nx.write_gexf(nx.random_lobster(100, 0.5, 0.5, seed=0), 'lobster.gexf')\"\nrandom_lobster(n, p, q, seed=None) returns a lobster with approximately n vertices in the backbone, backbone edges with probability p and leaves with probability q.\nThe seed is set to zero for the sake of reproducibility.\n\n\nForce-directed drawing algorithms\nThe type of drawing we are looking for, one with as few edge crossings and different edge lengths as possible is the kind of drawing that force-directed algorithms are designed to produce. Force-directed drawing algorithms use simulations of forces between nodes to decide node placements. Electrical forces have the effect of making non-adjacent nodes move further apart and spring forces between adjacent nodes have the effect of reducing variability of edge lengths.\nGephi makes the standard Fruchterman-Reingold force-directed algorithm available alongside a layout method called Force-Atlas.\nThese two layout methods, although both built on force-directed foundations, produce wildly different layouts with the same lobster graph input.\nBeginning with random placement of nodes, the Fruchterman-Reingold algorithm in Gephi produces a layout having uniform distribution of nodes across a disk. Albeit one having very many edge-crossings.\n\n\n\n\n\nThis is a well-known problem with force-directed methods. The algorithm has probably discovered a local minimum. Unfortunately this local minimum is far from the global minimum.\nThe Force-Atlas algorithm, on the other hand, creates a layout which has few crossings but without the nice node distribution of the Fruchterman-Reingold layout.\n\n\n\n\n\nGephi makes it easy to experiment with combining methods to produce a layout which has the benefits of both.\n\n\nCombining Force-Atlas and Fruchterman-Reingold Layout Algorithms\nFirst using the Force-Atlas method to find a nearly plane drawing and then using the Fruchterman-Reingold algorithm on the resulting drawing produces a new drawing that is both nearly planar and has evenly distributed nodes with relatively few different edge lengths.\n\n\n\n\n\nAnother benefit of Gephi, not illustrated here, is that some of the layout methods allow for interaction during execution. This means that, where there are edge-crossings we can manually move vertices around a little bit to help eliminate them. So a layout like the one shown, which has few edge crossings can probably be improved to a plane drawing with a little manual interaction."
  },
  {
    "objectID": "posts/2014-07-25-colouring-small-graphs/index.html",
    "href": "posts/2014-07-25-colouring-small-graphs/index.html",
    "title": "Colouring Small Graphs",
    "section": "",
    "text": "In Chromatic Polynomials we showed how to partially reproduce the data on small graph colourings made available by Gordon Royle. In that post we used NetworkX, sympy and the tutte_bhkk module of Björklund et al. (2008) to reproduce Royle’s results up to order \\(n = 7\\).\nIn A Chromatic Number Program we developed a tool, chromatic, for computing chromatic numbers based on tutte, an implementation of the Tutte polynomial by Haggard, Pearce, and Royle (2010) .\nIn this post we attempt to reproduce Royle’s chromatic number distribution data with chromatic."
  },
  {
    "objectID": "posts/2014-07-25-colouring-small-graphs/index.html#a-small-chromatic-hack",
    "href": "posts/2014-07-25-colouring-small-graphs/index.html#a-small-chromatic-hack",
    "title": "Colouring Small Graphs",
    "section": "A Small Chromatic Hack",
    "text": "A Small Chromatic Hack\nThe chromatic script that we introduced last week had at least one flaw. It was not able to correctly calculate the chromatic number of a graph with no edges. This seems to be due to the fact that the input format for the tutte program used to calculate the chromatic polynomial does not support empty (i.e. edge-less) graphs.\nOne solution, shown below, is to calculate, using the Graphviz program gc the number of edges in the input graph. If this number is zero then we return 1 and exit the script.\nn_edges=`gc -e $file_gv\\\n         | sed -n 's/\\([0-9]*\\) %.*/\\1/p'\\\n         | tr -d ' '`\n\nif [[ ${n_edges} -eq 0 ]] ; then\n    echo 1\n    exit 1\nfi"
  },
  {
    "objectID": "posts/2014-07-25-colouring-small-graphs/index.html#simulation-overview",
    "href": "posts/2014-07-25-colouring-small-graphs/index.html#simulation-overview",
    "title": "Colouring Small Graphs",
    "section": "Simulation Overview",
    "text": "Simulation Overview\nMost of the work in this simulation is done by a single Bash script. In addition to looping through the graph data computing chromatic numbers we also have to first convert data into the right format and, afterwards, analyse the results.\nMore specifically, we have to do the following things:\n\nConvert graph6 graph data from Brendan McKay’s homepage into Graphviz DOT format.\nIterate through all connected graphs of order at most 7 and for each graph compute the chromatic number and append it to a file of chromatic numbers of all connected graphs of the same order.\nAnalyse the distribution of chromatic numbers in the resulting results files.\n\nIn the rest of this post we describe each of these steps in more detail."
  },
  {
    "objectID": "posts/2014-07-25-colouring-small-graphs/index.html#data-conversion",
    "href": "posts/2014-07-25-colouring-small-graphs/index.html#data-conversion",
    "title": "Colouring Small Graphs",
    "section": "Data Conversion",
    "text": "Data Conversion\nWe begin with the small graph data from Brendan McKay’s homepage. Among the various files he has made available are a collection which contain all graphs of order 10 or less. These are made available in graph6 format with one graph per line in files that contain all graphs of a specific order. A separate collection gives all of the connected graphs of order at most 10. The latter is the collection we are going to be using.\nAs things stand, chromatic, reads one graph at a time from an input file and that graph is expected to be in Graphviz DOT format. In the future it will be possible to run chromatic directly on graph6 data but for now we just do the conversion to DOT format before running the simulation.\nA Makefile that converts the graph6 data into folders of files in DOT format, with one file per graph, has been added to the graphs-collection project. So to build this data we now merely clone the graphs-collection repository and call make from the src/Small folder.\nDoing this creates a new folder src/Small/output which contains subfolders n_gv and nc_gv for all \\(2 \\leq n \\leq 8\\). The folder n_gv contains all graphs of order \\(n\\) in DOT format and the folder nc_gv contains all connected graphs of order \\(n\\) in DOT format."
  },
  {
    "objectID": "posts/2014-07-25-colouring-small-graphs/index.html#the-main-loop",
    "href": "posts/2014-07-25-colouring-small-graphs/index.html#the-main-loop",
    "title": "Colouring Small Graphs",
    "section": "The Main Loop",
    "text": "The Main Loop\nOnce we have the data in DOT format our simulation is a very simple Bash script that takes two arguments, a lower and upper bound. The chromatic numbers of all (connected) graphs of orders between the lower and upper bounds are computed and stored in results files, one chromatic number per line, for subsequent analysis.\n#!/bin/bash\n\nBASEDIR=~/workspace/graphs-collection/src/Small/output\n\nfor order in `seq $1 $2`;\ndo\n echo ${order}\n graphs=`ls ${BASEDIR}/${order}c_gv/*`\n for graph in ${graphs};\n do\n  chromatic ${graph} &gt;&gt; ${order}c_result.txt;\n done\ndone\nThe BASEDIR variable in this script points to the output folder generated in the previous step."
  },
  {
    "objectID": "posts/2014-07-25-colouring-small-graphs/index.html#analysis",
    "href": "posts/2014-07-25-colouring-small-graphs/index.html#analysis",
    "title": "Colouring Small Graphs",
    "section": "Analysis",
    "text": "Analysis\nA second small Bash script now is used to process the output from the previous step and collate the chromatic numbers for each order. This script also takes two parameters as input, the upper and lower bounds on order.\n#!/bin/bash\n\nRESULTS_DIR=results/14_07_31_results\n\nfor i in `seq $1 $2`\ndo\n echo order: $i\n for j in `seq 1 8`\n do\n echo $j: `grep -c $j ${RESULTS_DIR}/${i}c_result.txt`\n done\ndone\nHere RESULT_DIR points to the location of the folder containing the output from the previous step"
  },
  {
    "objectID": "posts/2014-07-25-colouring-small-graphs/index.html#results",
    "href": "posts/2014-07-25-colouring-small-graphs/index.html#results",
    "title": "Colouring Small Graphs",
    "section": "Results",
    "text": "Results\nThe data collected by the simulation described above agrees with Royle’s table for all \\(n \\leq 6\\). For \\(n = 7\\) we get the following numbers, which are obviously wrong.\n\n\n\n2\n3\n4\n5\n6\n7\n\n\n\n\n44\n486\n294\n29\n0\n0\n\n\n\nWe would expect that the number of connected graphs of order 7 having chromatic number 7 is (at least) 1. We also expect that there are connected graphs of order 7 having chromatic number 6. Those last two zeros, therefore, point to a flaw in our simulation.\nIt seems most likely that the error was introduced in converting the data from graph6 to DOT format. Our methods for converting are not designed with much rigour and it seems plausible that they aren’t reliable for larger graphs. There are at least a couple of things we can do to progress and hopefully fix this problem.\nOne method is to improve the reliability of our conversion tools. To do this we should match the conversions described in the Makefile in graphs-collection with some testing of basic parameters in the resulting data.\nAnother approach is to modify chromatic to work with files in graph6 one graph per line format.\nIn upcoming posts we will look at both of these approaches and return to Royle’s data with a view to reproducing his results as far as possible."
  }
]